<!DOCTYPE HTML>
<html lang="zh" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>MySQL必知必会</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> 了解SQL</a></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> MySQL简介</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> 使用MySQL</a></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">4.</strong> 检索数据</a></li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">5.</strong> 排序检索数据</a></li><li class="chapter-item expanded "><a href="chapter_6.html"><strong aria-hidden="true">6.</strong> 过滤数据</a></li><li class="chapter-item expanded "><a href="chapter_7.html"><strong aria-hidden="true">7.</strong> 数据过滤</a></li><li class="chapter-item expanded "><a href="chapter_8.html"><strong aria-hidden="true">8.</strong> 用通配符进行过滤</a></li><li class="chapter-item expanded "><a href="chapter_9.html"><strong aria-hidden="true">9.</strong> 用正则表达式进行搜索</a></li><li class="chapter-item expanded "><a href="chapter_10.html"><strong aria-hidden="true">10.</strong> 创建计算字段</a></li><li class="chapter-item expanded "><a href="chapter_11.html"><strong aria-hidden="true">11.</strong> 使用数据处理函数</a></li><li class="chapter-item expanded "><a href="chapter_12.html"><strong aria-hidden="true">12.</strong> 汇总数据</a></li><li class="chapter-item expanded "><a href="chapter_13.html"><strong aria-hidden="true">13.</strong> 数据分组</a></li><li class="chapter-item expanded "><a href="chapter_14.html"><strong aria-hidden="true">14.</strong> 使用子查询</a></li><li class="chapter-item expanded "><a href="chapter_15.html"><strong aria-hidden="true">15.</strong> 联结表</a></li><li class="chapter-item expanded "><a href="chapter_16.html"><strong aria-hidden="true">16.</strong> 创建高级联结</a></li><li class="chapter-item expanded "><a href="chapter_17.html"><strong aria-hidden="true">17.</strong> 组合查询</a></li><li class="chapter-item expanded "><a href="chapter_18.html"><strong aria-hidden="true">18.</strong> 全文本搜索</a></li><li class="chapter-item expanded "><a href="chapter_19.html"><strong aria-hidden="true">19.</strong> 插入数据</a></li><li class="chapter-item expanded "><a href="chapter_20.html"><strong aria-hidden="true">20.</strong> 更新和删除数据</a></li><li class="chapter-item expanded "><a href="chapter_21.html"><strong aria-hidden="true">21.</strong> 创建和操纵表</a></li><li class="chapter-item expanded "><a href="chapter_22.html"><strong aria-hidden="true">22.</strong> 使用视图</a></li><li class="chapter-item expanded "><a href="chapter_23.html"><strong aria-hidden="true">23.</strong> 使用存储过程</a></li><li class="chapter-item expanded "><a href="chapter_24.html"><strong aria-hidden="true">24.</strong> 使用游标</a></li><li class="chapter-item expanded "><a href="chapter_25.html"><strong aria-hidden="true">25.</strong> 使用触发器</a></li><li class="chapter-item expanded "><a href="chapter_26.html"><strong aria-hidden="true">26.</strong> 管理事务处理</a></li><li class="chapter-item expanded "><a href="appendixD.html"><strong aria-hidden="true">27.</strong> 附录D MySQL数据类型</a></li><li class="chapter-item expanded "><a href="appendix_create.html"><strong aria-hidden="true">28.</strong> 附录.创建示例数据库结构</a></li><li class="chapter-item expanded "><a href="appendix_insert.html"><strong aria-hidden="true">29.</strong> 附录.添加示例数据</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">MySQL必知必会</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="1-了解sql"><a class="header" href="#1-了解sql">1 了解SQL</a></h1>
<h2 id="11-数据库基础"><a class="header" href="#11-数据库基础">1.1 数据库基础</a></h2>
<h3 id="111-什么是数据库"><a class="header" href="#111-什么是数据库">1.1.1 什么是数据库</a></h3>
<p><strong>数据库:</strong> 保存有组织的数据的容器。</p>
<h3 id="112-表"><a class="header" href="#112-表">1.1.2 表</a></h3>
<p><strong>表:</strong> 某种特定类型数据的结构化清单。</p>
<p>表具有一些特性，这些特性定义了数据在表中如何存储，如可以存储什么样的数据，数据如何分解，各部分信息如何命名，等等。描述表的这组信息就是所谓的模式，模式可以用来描述数据库中特定的表以及整个数据库（和其中表的关系）。</p>
<p><strong>模式(schema):</strong> 关于数据库和表的布局特性的信息。</p>
<h3 id="113-列和数据类型"><a class="header" href="#113-列和数据类型">1.1.3 列和数据类型</a></h3>
<p><strong>列(column):</strong> 表中的一个字段。所有表都是由一个或多个列组成的。</p>
<p><strong>数据类型(datatype):</strong> 所容许的数据的类型。每个表列都有相应的数据类型，它限制（或容许）该列中存储的数据。</p>
<h3 id="114-行"><a class="header" href="#114-行">1.1.4 行</a></h3>
<p><strong>行(row):</strong> 表中的一个记录。</p>
<h3 id="115-主键"><a class="header" href="#115-主键">1.1.5 主键</a></h3>
<p><strong>主键(primary key):</strong> 一列（或一组列），其值能够唯一区分表中每个行。</p>
<p><em>应该总是定义主键</em> 虽然并不总是都需要主键，但大多数数据库设计人员都应保证他们创建的每个表具有一个主键，以便于以后的数据操纵和管理。</p>
<p>表中的任何列都可以作为主键，只要它满足以下条件：</p>
<ul>
<li>任意两行都不具有相同的主键值；</li>
<li>每个行都必须具有一个主键值（主键列不允许NULL值）。</li>
</ul>
<p>主键通常定义在表的一列上，但这并不是必需的，也可以一起使用多个列作为主键。在使用多列作为主键时，上述条件必须应用到构成主键的所有列，所有列值的组合必须是唯一的（但单个列的值可以不唯一）。</p>
<p><em>主键的最好习惯</em>  除MySQL强制实施的规则外，应该坚持的几个普遍认可的最好习惯为：</p>
<ul>
<li>不更新主键列中的值；</li>
<li>不重用主键列的值；</li>
<li>不在主键列中使用可能会更改的值。（例如，如果使用一个名字作为主键以标识某个供应商，当该供应商合并和更改其名字时，必须更改这个主键。）</li>
</ul>
<h2 id="12-什么是sql"><a class="header" href="#12-什么是sql">1.2 什么是SQL</a></h2>
<p><strong>SQL</strong>是结构化查询语言(Structed Query Language)的缩写。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-mysql简介"><a class="header" href="#2-mysql简介">2 MySQL简介</a></h1>
<h2 id="22-mysql工具"><a class="header" href="#22-mysql工具">2.2 MySQL工具</a></h2>
<h3 id="221-mysql命令行实用程序"><a class="header" href="#221-mysql命令行实用程序">2.2.1 mysql命令行实用程序</a></h3>
<p>熟悉mysql命令行实用程序  即使你选择使用后面描述的某个图形工具，也应该保证熟悉mysql命令行实用程序，因为它是你可以安全地依靠的一个总是会被给出的客户机（因为它是核心MySQL安装的一部分）。</p>
<h3 id="222-mysql-administrator"><a class="header" href="#222-mysql-administrator">2.2.2 MySQL Administrator</a></h3>
<p><strong>获得MySQL Administrator</strong>  MySQL Administrator不作为核心MySQL的组成部分安装。必须从<a href="http://dev.mysql.com/downloads/">http://dev.mysql.com/downloads/</a>下载它（可得到用于Linux、Mac OS X和Windows的版本，其源代码也可以下载）。</p>
<h3 id="223-mysql-query-browser"><a class="header" href="#223-mysql-query-browser">2.2.3 MySQL Query Browser</a></h3>
<p>MySQL Query Browser为一个图形交互客户机，用来编写和执行MySQL命令。</p>
<p><strong>获得MySQL Query Browser</strong> 与MySQL Administrator一样，MySQL Query Browser不作为核心MySQL安装的成分。也必须从<a href="http://dev.mysql.com/downloads/">http://dev.mysql.com/downloads/</a>下载它（可得到用于Linux、Mac OS X和Windows的版本，其源代码也可以下载）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-使用mysql"><a class="header" href="#3-使用mysql">3 使用MySQL</a></h1>
<h2 id="32-选择数据库"><a class="header" href="#32-选择数据库">3.2 选择数据库</a></h2>
<p>在你最初连接到MySQL时，没有任何数据库打开供你使用。在你能执行任意数据库操作前，需要选择一个数据库。为此，可使用<strong>USE</strong>关键字。</p>
<pre><code class="language-SQL">mysql&gt; USE crashcourse;
Database changed
</code></pre>
<h2 id="33-了解数据库和表"><a class="header" href="#33-了解数据库和表">3.3 了解数据库和表</a></h2>
<p>不知道可使用的数据库名？<code>SHOW DATABASES;</code> 可返回可用数据库的一个列表。</p>
<pre><code class="language-SQL">mysql&gt; SHOW DATABASES;
+-------------+
| Database    |
+-------------+
| databse1    |
| databse2    |
+-------------+
</code></pre>
<p>获得一个数据库内的表的列表？<code>SHOW TABLES;</code> 返回当前选择的数据库内可用表的列表。</p>
<pre><code class="language-SQL">mysql&gt; SHOW TABLES;
+-----------------------+
| Tables_in_testdata    |
+-----------------------+
| table001              |
| table002              |
+-----------------------+
</code></pre>
<p>SHOW也可以用来显示表列</p>
<pre><code class="language-SQL">mysql&gt; SHOW COLUMNS FROM table001;
+--------+---------+---------+---------+---------+---------------+
| Field  | Type    | Null    | Key     | Default | Extra         |
+--------+---------+---------+---------+---------+---------------+
| id     | int(11) | NO      | PRI     | NULL    |auto_increment |
+--------+---------+---------+---------+---------+---------------+
mysql&gt; DESCRIBE table001;
+--------+---------+---------+---------+---------+---------------+
| Field  | Type    | Null    | Key     | Default | Extra         |
+--------+---------+---------+---------+---------+---------------+
| id     | int(11) | NO      | PRI     | NULL    |auto_increment |
+--------+---------+---------+---------+---------+---------------+
</code></pre>
<p>SHOW COLUMNS要求给出一个表名，它对每个字段返回一行，行中包含字段名、数据类型、是否允许NULL、键信息、默认值以及其他信息（如auto_increment）。</p>
<p><code>SHOW STATUS;</code>用于显示广泛的服务器状态信息。</p>
<p><code>SHOW CREATE DATABASE</code> 和 <code>SHOW CREATE TABLE</code>，分别用来显示创建特定数据库或表的MySQL语句；</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; show create database testdatabase;
+--------------+-----------------------------------------------------------------------------------------------------+
| Database     | Create Database                                                                                     |
+--------------+-----------------------------------------------------------------------------------------------------+
| testdatabase | CREATE DATABASE `testdatabase` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */ |
+--------------+-----------------------------------------------------------------------------------------------------+
MariaDB [testdatabase]&gt; show create table tasks;
+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Table | Create Table                                                                                                              
                                                                                                                                    
                                                                                                                       |
+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| tasks | CREATE TABLE `tasks` (
  `Id` int(11) NOT NULL AUTO_INCREMENT,
  `Name` varchar(50) NOT NULL,
  `Result` tinyint(1) DEFAULT 0,
  `Fault` int(11) DEFAULT 0,
  `Correct` int(11) DEFAULT 0,
  `Description` varchar(100) DEFAULT NULL,
  `Parent` varchar(200) DEFAULT NULL,
  PRIMARY KEY (`Id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci |
+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
</code></pre>
<p><code>SHOW GRANTS</code>，用来显示授予用户（所有用户或特定用户）的安全权限；</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SHOW GRANTS;
+----------------------------------------------------------------------------------------------------------------------------------------+
| Grants for root@localhost                                                                                                              |
+----------------------------------------------------------------------------------------------------------------------------------------+
| GRANT ALL PRIVILEGES ON *.* TO `root`@`localhost` IDENTIFIED BY PASSWORD '*DE0A26A6E94640F86D1505CF278C382693A1D00A' WITH GRANT OPTION |
| GRANT PROXY ON ''@'%' TO 'root'@'localhost' WITH GRANT OPTION                                                                          |
+----------------------------------------------------------------------------------------------------------------------------------------+
</code></pre>
<p><code>SHOW ERRORS</code> 和 <code>SHOW WARNINGS</code>，用来显示服务器错误或警告消息。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-检索数据"><a class="header" href="#4-检索数据">4 检索数据</a></h1>
<h2 id="41-select语句"><a class="header" href="#41-select语句">4.1 SELECT语句</a></h2>
<p>SQL语句是由简单的英语单词构成的。这些单词称为关键字，每个SQL语句都是由一个或多个关键字构成的。大概，最经常使用的SQL语句就是SELECT语句了。它的用途是从一个或多个表中检索信息。</p>
<p>为了使用SELECT检索表数据，必须至少给出两条信息——想选择什么，以及从什么地方选择。</p>
<h2 id="42-检索单个列"><a class="header" href="#42-检索单个列">4.2 检索单个列</a></h2>
<pre><code class="language-SQL">MariaDB [mysql]&gt; SELECT user FROM user;
+-------+
| user  |
+-------+
| masha |
| root  |
| masha |
| root  |
+-------+
</code></pre>
<p>如果未经指定，返回的数据是未排序的。</p>
<p><strong>结束SQL语句</strong> 多条SQL语句必须以分号（;）分隔。MySQL如同多数DBMS一样，不需要在单条SQL语句后加分号。但特定的DBMS可能必须在单条SQL语句后加上分号。当然，如果愿意可以总是加上分号。事实上，即使不一定需要，但加上分号肯定没有坏处。如果你使用的是mysql命令行，必须加上分号来结束SQL语句。</p>
<h2 id="43-检索多个列"><a class="header" href="#43-检索多个列">4.3 检索多个列</a></h2>
<pre><code class="language-SQL">MariaDB [mysql]&gt; SELECT user, host FROM user;
+-------+-----------+
| user  | host      |
+-------+-----------+
| masha | %         |
| root  | %         |
| masha | localhost |
| root  | localhost |
+-------+-----------+
</code></pre>
<h2 id="44-检索所有列"><a class="header" href="#44-检索所有列">4.4 检索所有列</a></h2>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT * FROM tasks;
+----+-----------------+--------+-------+---------+-------------+--------+
| Id | Name            | Result | Fault | Correct | Description | Parent |
+----+-----------------+--------+-------+---------+-------------+--------+
|  1 | db_create_test  |      1 |     0 |       0 | NULL        | NULL   |
|  2 | db_create_test1 |      1 |     0 |       0 |             |        |
+----+-----------------+--------+-------+---------+-------------+--------+
</code></pre>
<p><strong>使用通配符</strong>  一般，除非你确实需要表中的每个列，否则最好别使用*通配符。虽然使用通配符可能会使你自己省事，不用明确列出所需列，但检索不需要的列通常会降低检索和应用程序的性能。</p>
<p><strong>检索未知列</strong>  使用通配符有一个大优点。由于不明确指定列名（因为星号检索每个列），所以能检索出名字未知的列。</p>
<h2 id="45-检索不同的行"><a class="header" href="#45-检索不同的行">4.5 检索不同的行</a></h2>
<pre><code class="language-SQL">MariaDB [mysql]&gt; SELECT DISTINCT user FROM user;
+-------+
| user  |
+-------+
| masha |
| root  |
+-------+
</code></pre>
<p>使用DISTINCT关键字指示MySQL只返回不同的值。</p>
<p><strong>不能部分使用DISTINCT</strong> DISTINCT关键字应用于所有列而不仅是前置它的列。如果给出SELECT DISTINCT vend_id, prod_price，除非指定的两个列都不同，否则所有行都将被检索出来。</p>
<h2 id="46-限制结果"><a class="header" href="#46-限制结果">4.6 限制结果</a></h2>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT Id FROM tasks;
+----+
| Id |
+----+
|  1 |
|  2 |
+----+
2 rows in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT Id FROM tasks LIMIT 1;
+----+
| Id |
+----+
|  1 |
+----+
1 row in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT Id FROM tasks LIMIT 1,1;
+----+
| Id |
+----+
|  2 |
+----+
1 row in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT Id FROM tasks LIMIT 1,5;
+----+
| Id |
+----+
|  2 |
+----+
1 row in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT Id FROM tasks LIMIT 5 OFFSET 1;
+----+
| Id |
+----+
|  2 |
+----+
1 row in set (0.000 sec)
</code></pre>
<p>带一个值的LIMIT总是从第一行开始，给出的数为返回的行数。</p>
<p>带两个值的LIMIT可以指定从行号为第一个值的位置开始。</p>
<p><strong>行0</strong> 检索出来的第一行为行0而不是行1。因此，LIMIT 1, 1将检索出第二行而不是第一行。</p>
<p><strong>在行数不够时</strong> LIMIT中指定要检索的行数为检索的最大行数。如果没有足够的行（例如，给出LIMIT 1, 5，但只有2行），MySQL将只返回它能返回的那么多行。</p>
<p>由于LIMIT的这个原因，MySQL 5支持LIMIT的另一种替代语法。LIMIT 4 OFFSET 3意为从行3开始取4行，就像LIMIT 3, 4一样。</p>
<h2 id="47-使用完全限定的表名"><a class="header" href="#47-使用完全限定的表名">4.7 使用完全限定的表名</a></h2>
<p>使用完全限定的名字来引用列（同时使用表名和列字）。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT tasks.Name FROM tasks;
+-----------------+
| Name            |
+-----------------+
| db_create_test  |
| db_create_test1 |
+-----------------+
2 rows in set (0.000 sec)
</code></pre>
<p>表名也可以是完全限定的</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT tasks.Name FROM tasks;
+-----------------+
| Name            |
+-----------------+
| db_create_test  |
| db_create_test1 |
+-----------------+
2 rows in set (0.000 sec)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="5-排序检索数据"><a class="header" href="#5-排序检索数据">5 排序检索数据</a></h1>
<p>检索出的数据并不是以纯粹的随机顺序显示的。如果不排序，数据一般将以它在底层表中出现的顺序显示。这可以是数据最初添加到表中的顺序。但是，如果数据后来进行过更新或删除，则此顺序将会受到MySQL重用回收存储空间的影响。因此，如果不明确控制的话，不能（也不应该）依赖该排序顺序。关系数据库设计理论认为，如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有意义。</p>
<h2 id="51-排序数据"><a class="header" href="#51-排序数据">5.1 排序数据</a></h2>
<p><strong>子句（clause）</strong> SQL语句由子句构成，有些子句是必需的，而有的是可选的。一个子句通常由一个关键字和所提供的数据组成。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT Name FROM tasks ORDER BY Id;
+-----------------+
| Name            |
+-----------------+
| db_create_test  |
| db_create_test1 |
+-----------------+
2 rows in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT Name FROM tasks ORDER BY Id DESC;
+-----------------+
| Name            |
+-----------------+
| db_create_test1 |
| db_create_test  |
+-----------------+
2 rows in set (0.000 sec)
</code></pre>
<p>ORDER BY子句取一个或多个列的名字，据此对输出进行排序。</p>
<p><strong>通过非选择列进行排序</strong> 通常，ORDER BY子句中使用的列将是为显示所选择的列。但是，实际上并不一定要这样，用非检索的列排序数据是完全合法的。</p>
<h2 id="52-按多个列排序"><a class="header" href="#52-按多个列排序">5.2 按多个列排序</a></h2>
<p>为了按多个列排序，只要指定列名，列名之间用逗号分开即可（就像选择多个列时所做的那样）。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT id,fault,correct FROM tasks ORDER BY fault, id;
+----+-------+---------+
| id | fault | correct |
+----+-------+---------+
|  2 |     0 |       1 |
|  1 |     1 |       0 |
|  3 |     1 |       0 |
+----+-------+---------+
3 rows in set (0.010 sec)
</code></pre>
<p>重要的是理解在按多个列排序时，排序完全按所规定的顺序进行。换句话说，对于上述例子中的输出，仅在多个行具有相同的fault值时才对产品按id进行排序。如果fault列中所有的值都是唯一的，则不会按id排序。</p>
<h2 id="53-指定排序方向"><a class="header" href="#53-指定排序方向">5.3 指定排序方向</a></h2>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT id,fault,correct FROM tasks ORDER BY fault, id;
+----+-------+---------+
| id | fault | correct |
+----+-------+---------+
|  2 |     0 |       1 |
|  1 |     1 |       0 |
|  3 |     1 |       0 |
+----+-------+---------+
3 rows in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT id,fault,correct FROM tasks ORDER BY fault, id DESC;
+----+-------+---------+
| id | fault | correct |
+----+-------+---------+
|  2 |     0 |       1 |
|  3 |     1 |       0 |
|  1 |     1 |       0 |
+----+-------+---------+
3 rows in set (0.000 sec)
</code></pre>
<p>DESC关键字只应用到直接位于其前面的列名。在上例中，只对id列指定DESC，对fault列不指定。因此，id列以降序排序，而fault列仍然按标准的升序排序。</p>
<p><strong>在多个列上降序排序</strong> 如果想在多个列上进行降序排序，必须对每个列指定DESC关键字。</p>
<p><strong>区分大小写和排序顺序</strong> 在对文本性的数据进行排序时，A与a相同吗？a位于B之前还是位于Z之后？这些问题不是理论问题，其答案取决于数据库如何设置。</p>
<ul>
<li>在字典（dictionary）排序顺序中，A被视为与a相同，这是MySQL（和大多数数据库管理系统）的默认行为。但是，许多数据库管理员能够在需要时改变这种行为（如果你的数据库包含大量外语字符，可能必须这样做）。</li>
<li>这里，关键的问题是，如果确实需要改变这种排序顺序，用简单的ORDER BY子句做不到。你必须请求数据库管理员的帮助。</li>
</ul>
<p><strong>ORDER BY子句的位置</strong> 在给出ORDER BY子句时，应该保证它位于FROM子句之后。如果使用LIMIT，它必须位于ORDER BY之后。使用子句的次序不对将产生错误消息。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="6-过滤数据"><a class="header" href="#6-过滤数据">6 过滤数据</a></h1>
<h2 id="61-使用where子句"><a class="header" href="#61-使用where子句">6.1 使用WHERE子句</a></h2>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT id, name FROM tasks WHERE fault=1;
+----+-----------------+
| id | name            |
+----+-----------------+
|  1 | db_create_test  |
|  3 | db_create_test2 |
+----+-----------------+
2 rows in set (0.000 sec)
</code></pre>
<p><strong>SQL过滤与应用过滤</strong> 数据也可以在应用层过滤。为此目的，SQL的SELECT语句为客户机应用检索出超过实际所需的数据，然后客户机代码对返回数据进行循环，以提取出需要的行。</p>
<p>通常，这种实现并不令人满意。因此，对数据库进行了优化，以便快速有效地对数据进行过滤。让客户机应用（或开发语言）处理数据库的工作将会极大地影响应用的性能，并且使所创建的应用完全不具备可伸缩性。此外，如果在客户机上过滤数据，服务器不得不通过网络发送多余的数据，这将导致网络带宽的浪费。</p>
<h2 id="62-where子句操作符"><a class="header" href="#62-where子句操作符">6.2 WHERE子句操作符</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">操作符</th><th style="text-align: center">说明</th></tr></thead><tbody>
<tr><td style="text-align: center">=</td><td style="text-align: center">等于</td></tr>
<tr><td style="text-align: center">&lt;&gt;</td><td style="text-align: center">不等于</td></tr>
<tr><td style="text-align: center">!=</td><td style="text-align: center">不等于</td></tr>
<tr><td style="text-align: center">&lt;</td><td style="text-align: center">小于</td></tr>
<tr><td style="text-align: center">&lt;=</td><td style="text-align: center">小于等于</td></tr>
<tr><td style="text-align: center">&gt;</td><td style="text-align: center">大于</td></tr>
<tr><td style="text-align: center">&gt;=</td><td style="text-align: center">大于等于</td></tr>
<tr><td style="text-align: center">BETWEEN</td><td style="text-align: center">在指定的两个值之间</td></tr>
</tbody></table>
</div>
<h3 id="621-检查单个值"><a class="header" href="#621-检查单个值">6.2.1 检查单个值</a></h3>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT id, name FROM tasks WHERE fault=1;
+----+-----------------+
| id | name            |
+----+-----------------+
|  1 | db_create_test  |
|  3 | db_create_test2 |
+----+-----------------+
2 rows in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT id, name FROM tasks WHERE fault&lt;1;
+----+-----------------+
| id | name            |
+----+-----------------+
|  2 | db_create_test1 |
+----+-----------------+
1 row in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT id, name FROM tasks WHERE fault&lt;=1;
+----+-----------------+
| id | name            |
+----+-----------------+
|  1 | db_create_test  |
|  2 | db_create_test1 |
|  3 | db_create_test2 |
+----+-----------------+
3 rows in set (0.000 sec)
</code></pre>
<h3 id="622-不匹配检查"><a class="header" href="#622-不匹配检查">6.2.2 不匹配检查</a></h3>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT id, name FROM tasks WHERE fault&lt;&gt;0;
+----+-----------------+
| id | name            |
+----+-----------------+
|  1 | db_create_test  |
|  3 | db_create_test2 |
+----+-----------------+
2 rows in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT id, name FROM tasks WHERE fault!=0;
+----+-----------------+
| id | name            |
+----+-----------------+
|  1 | db_create_test  |
|  3 | db_create_test2 |
+----+-----------------+
2 rows in set (0.000 sec)
</code></pre>
<h3 id="623-范围值检查"><a class="header" href="#623-范围值检查">6.2.3 范围值检查</a></h3>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT id, name FROM tasks WHERE fault BETWEEN 1 AND 0;
Empty set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT id, name FROM tasks WHERE fault BETWEEN 0 AND 1;
+----+-----------------+
| id | name            |
+----+-----------------+
|  1 | db_create_test  |
|  2 | db_create_test1 |
|  3 | db_create_test2 |
+----+-----------------+
3 rows in set (0.000 sec)
</code></pre>
<p>在使用BETWEEN时，必须指定两个值——所需范围的低端值和高端值。这两个值必须用AND关键字分隔。BETWEEN匹配范围中所有的值，包括指定的开始值和结束值。</p>
<h3 id="624-空值检查"><a class="header" href="#624-空值检查">6.2.4 空值检查</a></h3>
<p>在创建表时，表设计人员可以指定其中的列是否可以不包含值。在一个列不包含值时，称其为包含空值NULL。</p>
<p><strong>NULL</strong> 无值（no value），它与字段包含0、空字符串或仅仅包含空格不同。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT name, description FROM tasks WHERE description IS NULL;
+-----------------+-------------+
| name            | description |
+-----------------+-------------+
| db_create_test  | NULL        |
| db_create_test2 | NULL        |
+-----------------+-------------+
2 rows in set (0.000 sec)
</code></pre>
<p><strong>NULL与不匹配</strong> 在通过过滤选择出不具有特定值的行时，你可能希望返回具有NULL值的行。但是，不行。因为未知具有特殊的含义，数据库不知道它们是否匹配，所以在匹配过滤或不匹配过滤时不返回它们。</p>
<p>因此，在过滤数据时，一定要验证返回数据中确实给出了被过滤列具有NULL的行。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT * FROM tasks;
+----+-----------------+--------+-------+---------+-------------+--------+
| Id | Name            | Result | Fault | Correct | Description | Parent |
+----+-----------------+--------+-------+---------+-------------+--------+
|  1 | db_create_test  |      1 |     1 |       0 | NULL        |        |
|  2 | db_create_test1 |      1 |     0 |       1 |             | NULL   |
|  3 | db_create_test2 |      0 |     1 |       0 | NULL        | NULL   |
+----+-----------------+--------+-------+---------+-------------+--------+
3 rows in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT parent FROM tasks WHERE description is not NULL;
+--------+
| parent |
+--------+
| NULL   |
+--------+
1 row in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT parent FROM tasks WHERE description is NULL;
+--------+
| parent |
+--------+
|        |
| NULL   |
+--------+
2 rows in set (0.001 sec)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="7-数据过滤"><a class="header" href="#7-数据过滤">7 数据过滤</a></h1>
<h2 id="71-组合where子句"><a class="header" href="#71-组合where子句">7.1 组合WHERE子句</a></h2>
<p>为了进行更强的过滤控制，MySQL允许给出多个WHERE子句。这些子句可以两种方式使用：以AND子句的方式或OR子句的方式使用。</p>
<p><strong>操作符（operator）</strong> 用来联结或改变WHERE子句中的子句的关键字。也称为逻辑操作符（logical operator）。</p>
<h3 id="711-and操作符"><a class="header" href="#711-and操作符">7.1.1 AND操作符</a></h3>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT * FROM tasks WHERE description is NULL AND parent is NULL;
+----+-----------------+--------+-------+---------+-------------+--------+
| Id | Name            | Result | Fault | Correct | Description | Parent |
+----+-----------------+--------+-------+---------+-------------+--------+
|  3 | db_create_test2 |      0 |     1 |       0 | NULL        | NULL   |
+----+-----------------+--------+-------+---------+-------------+--------+
1 row in set (0.000 sec)
</code></pre>
<p><strong>AND</strong> 用在WHERE子句中的关键字，用来指示检索<em>满足所有给定条件的行</em>。可以添加多个过滤条件，每添加一条就要使用一个AND。</p>
<h3 id="712-or操作符"><a class="header" href="#712-or操作符">7.1.2 OR操作符</a></h3>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT * FROM tasks WHERE description=&quot;&quot; OR parent=&quot;&quot;;
+----+-----------------+--------+-------+---------+-------------+--------+
| Id | Name            | Result | Fault | Correct | Description | Parent |
+----+-----------------+--------+-------+---------+-------------+--------+
|  1 | db_create_test  |      1 |     1 |       0 | NULL        |        |
|  2 | db_create_test1 |      1 |     0 |       1 |             | NULL   |
+----+-----------------+--------+-------+---------+-------------+--------+
2 rows in set (0.000 sec)
</code></pre>
<p><strong>OR</strong> WHERE子句中使用的关键字，用来表示检索匹配任一给定条件的行。</p>
<h3 id="713-计算次序"><a class="header" href="#713-计算次序">7.1.3 计算次序</a></h3>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT * FROM tasks;
+----+-----------------+--------+-------+---------+-------------+--------+
| Id | Name            | Result | Fault | Correct | Description | Parent |
+----+-----------------+--------+-------+---------+-------------+--------+
|  1 | db_create_test  |      1 |     1 |       0 | NULL        |        |
|  2 | db_create_test1 |      1 |     0 |       1 |             | NULL   |
|  3 | db_create_test2 |      0 |     1 |       0 | NULL        | NULL   |
+----+-----------------+--------+-------+---------+-------------+--------+
3 rows in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT * FROM tasks WHERE id=1 OR id=3 AND description IS NOT NULL;
+----+----------------+--------+-------+---------+-------------+--------+
| Id | Name           | Result | Fault | Correct | Description | Parent |
+----+----------------+--------+-------+---------+-------------+--------+
|  1 | db_create_test |      1 |     1 |       0 | NULL        |        |
+----+----------------+--------+-------+---------+-------------+--------+
1 row in set (0.000 sec)
</code></pre>
<p>上面的结果，AND指定了description不是NULL，但输出的description是NULL。如果先计算OR，应该得到id=1和id=3两行，然后计算AND，description非NULL，两行都不满足。这是因为<em><strong>SQL（像多数语言一样）在处理OR操作符前，优先处理AND操作符</strong></em>。</p>
<p>为了使运算按照预期，我们可以使用括号来分组操作符。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT * FROM tasks;
+----+-----------------+--------+-------+---------+-------------+--------+
| Id | Name            | Result | Fault | Correct | Description | Parent |
+----+-----------------+--------+-------+---------+-------------+--------+
|  1 | db_create_test  |      1 |     1 |       0 | NULL        |        |
|  2 | db_create_test1 |      1 |     0 |       1 |             | NULL   |
|  3 | db_create_test2 |      0 |     1 |       0 | NULL        | NULL   |
+----+-----------------+--------+-------+---------+-------------+--------+
3 rows in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT * FROM tasks WHERE (id=1 OR id=3) AND description IS NOT NULL;
Empty set (0.000 sec)
</code></pre>
<p><strong>在WHERE子句中使用圆括号</strong> 任何时候使用具有AND和OR操作符的WHERE子句，都应该使用圆括号明确地分组操作符。不要过分依赖默认计算次序，即使它确实是你想要的东西也是如此。使用圆括号没有什么坏处，它能消除歧义。</p>
<h2 id="72-in操作符"><a class="header" href="#72-in操作符">7.2 IN操作符</a></h2>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT * FROM tasks WHERE id IN (1,3);
+----+-----------------+--------+-------+---------+-------------+--------+
| Id | Name            | Result | Fault | Correct | Description | Parent |
+----+-----------------+--------+-------+---------+-------------+--------+
|  1 | db_create_test  |      1 |     1 |       0 | NULL        |        |
|  3 | db_create_test2 |      0 |     1 |       0 | NULL        | NULL   |
+----+-----------------+--------+-------+---------+-------------+--------+
2 rows in set (0.000 sec)
</code></pre>
<p><strong>IN</strong> WHERE子句中用来指定要匹配值的清单的关键字，功能与OR相当。优点: </p>
<ul>
<li>在使用长的合法选项清单时，IN操作符的语法更清楚且更直观。</li>
<li>在使用IN时，计算的次序更容易管理（因为使用的操作符更少）</li>
<li>IN操作符一般比OR操作符清单执行更快。</li>
<li>是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。</li>
</ul>
<h2 id="73-not操作符"><a class="header" href="#73-not操作符">7.3 NOT操作符</a></h2>
<p><strong>NOT</strong> WHERE子句中用来否定后跟条件的关键字。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT * FROM tasks;
+----+-----------------+--------+-------+---------+-------------+--------+
| Id | Name            | Result | Fault | Correct | Description | Parent |
+----+-----------------+--------+-------+---------+-------------+--------+
|  1 | db_create_test  |      1 |     1 |       0 | NULL        |        |
|  2 | db_create_test1 |      1 |     0 |       1 |             | NULL   |
|  3 | db_create_test2 |      0 |     1 |       0 | NULL        | NULL   |
+----+-----------------+--------+-------+---------+-------------+--------+
3 rows in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT * FROM tasks WHERE description IS NOT NULL;
+----+-----------------+--------+-------+---------+-------------+--------+
| Id | Name            | Result | Fault | Correct | Description | Parent |
+----+-----------------+--------+-------+---------+-------------+--------+
|  2 | db_create_test1 |      1 |     0 |       1 |             | NULL   |
+----+-----------------+--------+-------+---------+-------------+--------+
1 row in set (0.000 sec)
</code></pre>
<p><strong>为什么使用NOT?</strong> 对于简单的WHERE子句，使用NOT确实没有什么优势。但在更复杂的子句中，NOT是非常有用的。例如，在与IN操作符联合使用时，NOT使找出与条件列表不匹配的行非常简单。</p>
<p><strong>MySQL中的NOT</strong> MySQL支持使用NOT对IN、BETWEEN和EXISTS子句取反，这与多数其他DBMS允许使用NOT对各种条件取反有很大的差别。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="8-用通配符进行过滤"><a class="header" href="#8-用通配符进行过滤">8 用通配符进行过滤</a></h1>
<h2 id="81-like操作符"><a class="header" href="#81-like操作符">8.1 LIKE操作符</a></h2>
<p><strong>通配符（wildcard）</strong> 用来匹配值的一部分的特殊字符。</p>
<p><strong>搜索模式（search pattern）</strong> 由字面值、通配符或两者组合构成的搜索条件。</p>
<h3 id="811-百分号通配符"><a class="header" href="#811-百分号通配符">8.1.1 百分号(%)通配符</a></h3>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT * FROM tasks;
+----+-----------------+--------+-------+---------+-------------+--------+
| Id | Name            | Result | Fault | Correct | Description | Parent |
+----+-----------------+--------+-------+---------+-------------+--------+
|  1 | db_create_test  |      1 |     1 |       0 | NULL        |        |
|  2 | db_create_test1 |      1 |     0 |       1 |             | NULL   |
|  3 | db_create_test2 |      0 |     1 |       0 | NULL        | NULL   |
+----+-----------------+--------+-------+---------+-------------+--------+
3 rows in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT id, name FROM tasks WHERE name LIKE &quot;%1&quot;;
+----+-----------------+
| id | name            |
+----+-----------------+
|  2 | db_create_test1 |
+----+-----------------+
1 row in set (0.000 sec)
</code></pre>
<p>此例子使用了搜索模式'%1'。在执行这条子句时，将检索任意以1结尾的词。%告诉MySQL接受1之前的任意字符，不管它有多少字符。</p>
<p><strong>区分大小写</strong> 根据MySQL的配置方式，搜索可以是区分大小写的。如果区分大小写，'jet%'与JetPack将不匹配。</p>
<p>要注意到，除了一个或多个字符外，%还能匹配0个字符。%代表搜索模式中给定位置的0个、1个或多个字符。</p>
<p><strong>注意NULL</strong> 虽然似乎%通配符可以匹配任何东西，但有一个例外，即NULL。即使是WHERE prod_name LIKE '%'也不能匹配用值NULL作为产品名的行。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT * FROM tasks;
+----+-----------------+--------+-------+---------+-------------+--------+
| Id | Name            | Result | Fault | Correct | Description | Parent |
+----+-----------------+--------+-------+---------+-------------+--------+
|  1 | db_create_test  |      1 |     1 |       0 | NULL        |        |
|  2 | db_create_test1 |      1 |     0 |       1 |             | NULL   |
|  3 | db_create_test2 |      0 |     1 |       0 | NULL        | NULL   |
+----+-----------------+--------+-------+---------+-------------+--------+
3 rows in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT id, name FROM tasks WHERE description LIKE &quot;%&quot;;
+----+-----------------+
| id | name            |
+----+-----------------+
|  2 | db_create_test1 |
+----+-----------------+
1 row in set (0.000 sec)
</code></pre>
<h3 id="812-下划线_通配符"><a class="header" href="#812-下划线_通配符">8.1.2 下划线(_)通配符</a></h3>
<p>下划线的用途与%一样，但下划线只匹配单个字符而不是多个字符。</p>
<p>与%能匹配0个字符不一样，_总是匹配一个字符，不能多也不能少。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT * FROM tasks;
+----+-----------------+--------+-------+---------+-------------+--------+
| Id | Name            | Result | Fault | Correct | Description | Parent |
+----+-----------------+--------+-------+---------+-------------+--------+
|  1 | db_create_test  |      1 |     1 |       0 | NULL        |        |
|  2 | db_create_test1 |      1 |     0 |       1 |             | NULL   |
|  3 | db_create_test2 |      0 |     1 |       0 | NULL        | NULL   |
+----+-----------------+--------+-------+---------+-------------+--------+
3 rows in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT id, name FROM tasks WHERE name LIKE &quot;%test_&quot;;
+----+-----------------+
| id | name            |
+----+-----------------+
|  2 | db_create_test1 |
|  3 | db_create_test2 |
+----+-----------------+
2 rows in set (0.001 sec)
</code></pre>
<h2 id="82-使用通配符的技巧"><a class="header" href="#82-使用通配符的技巧">8.2 使用通配符的技巧</a></h2>
<p>正如所见，MySQL的通配符很有用。但这种功能是有代价的：通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。这里给出一些使用通配符要记住的技巧。</p>
<ul>
<li>不要过度使用通配符。<em><strong>如果其他操作符能达到相同的目的，应该使用其他操作符</strong></em>。 </li>
<li>在确实需要使用通配符时，除非绝对有必要，否则<em><strong>不要把它们用在搜索模式的开始处</strong></em>。把通配符置于搜索模式的开始处，搜索起来是最慢的。 </li>
<li>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="9-用正则表达式进行搜索"><a class="header" href="#9-用正则表达式进行搜索">9 用正则表达式进行搜索</a></h1>
<h2 id="92-使用mysql正则表达式"><a class="header" href="#92-使用mysql正则表达式">9.2 使用MySQL正则表达式</a></h2>
<p>MySQL仅支持多数正则表达式实现的一个很小的子集。</p>
<h3 id="921-基本字符匹配"><a class="header" href="#921-基本字符匹配">9.2.1 基本字符匹配</a></h3>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT * FROM tasks;
+----+-----------------+--------+-------+---------+-------------+--------+
| Id | Name            | Result | Fault | Correct | Description | Parent |
+----+-----------------+--------+-------+---------+-------------+--------+
|  1 | db_create_test  |      1 |     1 |       0 | NULL        |        |
|  2 | db_create_test1 |      1 |     0 |       1 |             | NULL   |
|  3 | db_create_test2 |      0 |     1 |       0 | NULL        | NULL   |
+----+-----------------+--------+-------+---------+-------------+--------+
3 rows in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT name FROM tasks WHERE name REGEXP 'test';
+-----------------+
| name            |
+-----------------+
| db_create_test  |
| db_create_test1 |
| db_create_test2 |
+-----------------+
3 rows in set (0.027 sec)

MariaDB [testdatabase]&gt; SELECT name FROM tasks WHERE name REGEXP 'test.';
+-----------------+
| name            |
+-----------------+
| db_create_test1 |
| db_create_test2 |
+-----------------+
2 rows in set (0.000 sec)
</code></pre>
<p>以上的功能可以由LIKE实现，正则表达式没有带来太多好处（可能还会降低性能）。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT * FROM tasks;
+----+-----------------+--------+-------+---------+-------------+--------+
| Id | Name            | Result | Fault | Correct | Description | Parent |
+----+-----------------+--------+-------+---------+-------------+--------+
|  1 | db_create_test  |      1 |     1 |       0 | NULL        |        |
|  2 | db_create_test1 |      1 |     0 |       1 |             | NULL   |
|  3 | db_create_test2 |      0 |     1 |       0 | NULL        | NULL   |
+----+-----------------+--------+-------+---------+-------------+--------+
3 rows in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT name FROM tasks WHERE name REGEXP 'test';
+-----------------+
| name            |
+-----------------+
| db_create_test  |
| db_create_test1 |
| db_create_test2 |
+-----------------+
3 rows in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT name FROM tasks WHERE name LIKE 'test';
Empty set (0.000 sec)
</code></pre>
<p><strong>LIKE和REGEXP</strong> LIKE匹配整个列。如果被匹配的文本在列值中出现，LIKE将不会找到它，相应的行也不被返回（除非使用通配符）。而REGEXP在列值内进行匹配，如果被匹配的文本在列值中出现，REGEXP将会找到它，相应的行将被返回。这是一个非常重要的差别。</p>
<p>REGEXP使用^和$定位符后也可以匹配整行。</p>
<p><strong>匹配不区分大小写</strong> MySQL中的正则表达式匹配（自版本3.23.4后）不区分大小写（即，大写和小写都匹配）。为区分大小写，可使用BINARY关键字，如WHERE prod_name REGEXP BINARY 'JetPack .000'。</p>
<h3 id="922-进行or匹配"><a class="header" href="#922-进行or匹配">9.2.2 进行OR匹配</a></h3>
<p>为搜索两个串之一（或者为这个串，或者为另一个串），使用 <code>|</code> 。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT * FROM tasks;
+----+-----------------+--------+-------+---------+-------------+--------+
| Id | Name            | Result | Fault | Correct | Description | Parent |
+----+-----------------+--------+-------+---------+-------------+--------+
|  1 | db_create_test  |      1 |     1 |       0 | NULL        |        |
|  2 | db_create_test1 |      1 |     0 |       1 |             | NULL   |
|  3 | db_create_test2 |      0 |     1 |       0 | NULL        | NULL   |
+----+-----------------+--------+-------+---------+-------------+--------+
3 rows in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT name FROM tasks WHERE name REGEXP 'test1|test2';
+-----------------+
| name            |
+-----------------+
| db_create_test1 |
| db_create_test2 |
+-----------------+
2 rows in set (0.000 sec)
</code></pre>
<p>使用 <code>|</code> 从功能上类似于在SELECT语句中使用OR语句，多个OR条件可并入单个正则表达式。</p>
<p><strong>两个以上的OR条件</strong> 可以给出两个以上的OR条件。例如，'1000 | 2000 | 3000'将匹配1000或2000或3000。</p>
<h3 id="923-匹配几个字符之一"><a class="header" href="#923-匹配几个字符之一">9.2.3 匹配几个字符之一</a></h3>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT * FROM tasks;
+----+-----------------+--------+-------+---------+-------------+--------+
| Id | Name            | Result | Fault | Correct | Description | Parent |
+----+-----------------+--------+-------+---------+-------------+--------+
|  1 | db_create_test  |      1 |     1 |       0 | NULL        |        |
|  2 | db_create_test1 |      1 |     0 |       1 |             | NULL   |
|  3 | db_create_test2 |      0 |     1 |       0 | NULL        | NULL   |
+----+-----------------+--------+-------+---------+-------------+--------+
3 rows in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT name FROM tasks WHERE name REGEXP 'test[12]';
+-----------------+
| name            |
+-----------------+
| db_create_test1 |
| db_create_test2 |
+-----------------+
2 rows in set (0.000 sec)
</code></pre>
<p>正如所见，[]是另一种形式的OR语句。事实上，正则表达式test[12]为test[1|2]的缩写，也可以使用后者。但是，需要用[]来定义OR语句查找什么。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT * FROM tasks;
+----+-----------------+--------+-------+---------+-------------+--------+
| Id | Name            | Result | Fault | Correct | Description | Parent |
+----+-----------------+--------+-------+---------+-------------+--------+
|  1 | db_create_test  |      1 |     1 |       0 | NULL        |        |
|  2 | db_create_test1 |      1 |     0 |       1 |             | NULL   |
|  3 | db_create_test2 |      0 |     1 |       0 | NULL        | NULL   |
|  4 | fake_case_1     |      1 |     0 |       0 |             |        |
+----+-----------------+--------+-------+---------+-------------+--------+
4 rows in set (0.001 sec)

MariaDB [testdatabase]&gt; SELECT name FROM tasks WHERE name REGEXP 'test2|1';
+-----------------+
| name            |
+-----------------+
| db_create_test1 |
| db_create_test2 |
| fake_case_1     |
+-----------------+
3 rows in set (0.001 sec)
</code></pre>
<p>这并不是期望的输出。两个要求的行被检索出来，但还检索出了另外1行。之所以这样是由于MySQL假定你的意思是'1'或'test2'。</p>
<p>字符集合也可以被否定，即，它们将匹配除指定字符外的任何东西。为否定一个字符集，在集合的开始处放置一个^即可。因此，尽管[123]匹配字符1、2或3，但<sup class="footnote-reference"><a href="#123">1</a></sup>却匹配除这些字符外的任何东西。</p>
<h3 id="924-匹配范围"><a class="header" href="#924-匹配范围">9.2.4 匹配范围</a></h3>
<p>范围不限于完整的集合，[1-3]和[6-9]也是合法的范围。此外，范围不一定只是数值的，[a-z]匹配任意字母字符。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT * FROM tasks;
+----+-----------------+--------+-------+---------+-------------+--------+
| Id | Name            | Result | Fault | Correct | Description | Parent |
+----+-----------------+--------+-------+---------+-------------+--------+
|  1 | db_create_test  |      1 |     1 |       0 | NULL        |        |
|  2 | db_create_test1 |      1 |     0 |       1 |             | NULL   |
|  3 | db_create_test2 |      0 |     1 |       0 | NULL        | NULL   |
|  4 | fake_case_1     |      1 |     0 |       0 |             |        |
+----+-----------------+--------+-------+---------+-------------+--------+
4 rows in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT name FROM tasks WHERE name REGEXP 'test[1-2]';
+-----------------+
| name            |
+-----------------+
| db_create_test1 |
| db_create_test2 |
+-----------------+
2 rows in set (0.000 sec)
</code></pre>
<h3 id="925-匹配特殊字符"><a class="header" href="#925-匹配特殊字符">9.2.5 匹配特殊字符</a></h3>
<p>点(.)匹配任意字符，因此每个行都被检索出来。为了匹配特殊字符，必须用\\为前导。\\-表示查找-，\\.表示查找.。这种处理就是所谓的转义（escaping），正则表达式内具有特殊意义的所有字符都必须以这种方式转义。这包括.、|、[]以及迄今为止使用过的其他特殊字符。</p>
<p>空白元字符</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">元符</th><th style="text-align: center">说明</th></tr></thead><tbody>
<tr><td style="text-align: center">\\f</td><td style="text-align: center">换页</td></tr>
<tr><td style="text-align: center">\\n</td><td style="text-align: center">换行</td></tr>
<tr><td style="text-align: center">\\r</td><td style="text-align: center">回车</td></tr>
<tr><td style="text-align: center">\\t</td><td style="text-align: center">制表</td></tr>
<tr><td style="text-align: center">\\v</td><td style="text-align: center">纵向制表</td></tr>
</tbody></table>
</div>
<p><strong>匹配\</strong>  为了匹配反斜杠（\）字符本身，需要使用\\。</p>
<p><strong>\或\\?</strong>  多数正则表达式实现使用单个反斜杠转义特殊字符，以便能使用这些字符本身。但MySQL要求两个反斜杠（MySQL自己解释一个，正则表达式库解释另一个）。</p>
<h3 id="926-匹配字符类"><a class="header" href="#926-匹配字符类">9.2.6 匹配字符类</a></h3>
<p>存在找出你自己经常使用的数字、所有字母字符或所有数字字母字符等的匹配。为更方便工作，可以使用预定义的字符集称为字符类（character class）。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">类</th><th style="text-align: center">说明</th></tr></thead><tbody>
<tr><td style="text-align: center">[:alnum:]</td><td style="text-align: center">任意字母和数字（同[a-zA-Z0-9]）</td></tr>
<tr><td style="text-align: center">[:alpha:]</td><td style="text-align: center">任意字符（同[a-zA-Z]）</td></tr>
<tr><td style="text-align: center">[:blank:]</td><td style="text-align: center">空格和制表（同[\t]）</td></tr>
<tr><td style="text-align: center">[:cntrl:]</td><td style="text-align: center">ASCII控制字符（ASCII0到31和127）</td></tr>
<tr><td style="text-align: center">[:digit:]</td><td style="text-align: center">任意数字（同[0-9]）</td></tr>
<tr><td style="text-align: center">[:graph:]</td><td style="text-align: center">与[:print:]相同，但不包括空格</td></tr>
<tr><td style="text-align: center">[:lower:]</td><td style="text-align: center">任意小写字母（同[a-z]）</td></tr>
<tr><td style="text-align: center">[:print:]</td><td style="text-align: center">任意可打印字符</td></tr>
<tr><td style="text-align: center">[:punct:]</td><td style="text-align: center">既不在[:alnum:]又不在[:cntrl:]中的任意字符</td></tr>
<tr><td style="text-align: center">[:space:]</td><td style="text-align: center">包括空格在内的任意空白字符（同[\\f\\n\\r\\t\\v]）</td></tr>
<tr><td style="text-align: center">[:upper:]</td><td style="text-align: center">任意大写字母（同[A-Z]）</td></tr>
<tr><td style="text-align: center">[:xdigit:]</td><td style="text-align: center">任意十六进制数字（同[a-fA-F0-9]）</td></tr>
</tbody></table>
</div>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT * FROM tasks;
+----+-----------------+--------+-------+---------+-------------+--------+
| Id | Name            | Result | Fault | Correct | Description | Parent |
+----+-----------------+--------+-------+---------+-------------+--------+
|  1 | db_create_test  |      1 |     1 |       0 | NULL        |        |
|  2 | db_create_test1 |      1 |     0 |       1 |             | NULL   |
|  3 | db_create_test2 |      0 |     1 |       0 | NULL        | NULL   |
|  4 | fake_case_1     |      1 |     0 |       0 |             |        |
|  5 | create_test12   |      1 |     2 |       0 | NULL        | NULL   |
+----+-----------------+--------+-------+---------+-------------+--------+
5 rows in set (0.001 sec)

MariaDB [testdatabase]&gt; SELECT name FROM tasks WHERE name REGEXP &quot;test[[:digit:]]*&quot;;
+-----------------+
| name            |
+-----------------+
| db_create_test  |
| db_create_test1 |
| db_create_test2 |
| create_test12   |
+-----------------+
4 rows in set (0.001 sec)

MariaDB [testdatabase]&gt; SELECT name FROM tasks WHERE name REGEXP &quot;test[[:digit:]]+&quot;;
+-----------------+
| name            |
+-----------------+
| db_create_test1 |
| db_create_test2 |
| create_test12   |
+-----------------+
3 rows in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT name FROM tasks WHERE name REGEXP &quot;test[[:digit:]]?&quot;;
+-----------------+
| name            |
+-----------------+
| db_create_test  |
| db_create_test1 |
| db_create_test2 |
| create_test12   |
+-----------------+
4 rows in set (0.001 sec)
</code></pre>
<h3 id="927-匹配多个实例"><a class="header" href="#927-匹配多个实例">9.2.7 匹配多个实例</a></h3>
<p>重复元字符</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">元字符</th><th style="text-align: center">说明</th></tr></thead><tbody>
<tr><td style="text-align: center">*</td><td style="text-align: center">0个或多个匹配</td></tr>
<tr><td style="text-align: center">+</td><td style="text-align: center">1个或多个匹配(等于{1，})</td></tr>
<tr><td style="text-align: center">?</td><td style="text-align: center">0个或1个匹配(等于{0，1})</td></tr>
<tr><td style="text-align: center">{n}</td><td style="text-align: center">指定数目的匹配</td></tr>
<tr><td style="text-align: center">{n,}</td><td style="text-align: center">不少于指定数目的匹配</td></tr>
<tr><td style="text-align: center">{n,m}</td><td style="text-align: center">匹配数目的范围(m不超过255)</td></tr>
</tbody></table>
</div>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT * FROM tasks;
+----+-----------------+--------+-------+---------+-------------+--------+
| Id | Name            | Result | Fault | Correct | Description | Parent |
+----+-----------------+--------+-------+---------+-------------+--------+
|  1 | db_create_test  |      1 |     1 |       0 | NULL        |        |
|  2 | db_create_test1 |      1 |     0 |       1 |             | NULL   |
|  3 | db_create_test2 |      0 |     1 |       0 | NULL        | NULL   |
|  4 | fake_case_1     |      1 |     0 |       0 |             |        |
|  5 | create_test12   |      1 |     2 |       0 | NULL        | NULL   |
+----+-----------------+--------+-------+---------+-------------+--------+
5 rows in set (0.001 sec)

MariaDB [testdatabase]&gt; SELECT name FROM tasks WHERE name REGEXP &quot;test[a-z0-9]*&quot;;
+-----------------+
| name            |
+-----------------+
| db_create_test  |
| db_create_test1 |
| db_create_test2 |
| create_test12   |
+-----------------+
4 rows in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT name FROM tasks WHERE name REGEXP &quot;test[a-z0-9]+&quot;;
+-----------------+
| name            |
+-----------------+
| db_create_test1 |
| db_create_test2 |
| create_test12   |
+-----------------+
3 rows in set (0.001 sec)

MariaDB [testdatabase]&gt; SELECT name FROM tasks WHERE name REGEXP &quot;test[a-z0-9]?&quot;;
+-----------------+
| name            |
+-----------------+
| db_create_test  |
| db_create_test1 |
| db_create_test2 |
| create_test12   |
+-----------------+
4 rows in set (0.001 sec)

MariaDB [testdatabase]&gt; SELECT name FROM tasks WHERE name REGEXP &quot;test[a-z0-9]{1}&quot;;
+-----------------+
| name            |
+-----------------+
| db_create_test1 |
| db_create_test2 |
| create_test12   |
+-----------------+
3 rows in set (0.001 sec)

MariaDB [testdatabase]&gt; SELECT name FROM tasks WHERE name REGEXP &quot;test[a-z0-9]{1,}&quot;;
+-----------------+
| name            |
+-----------------+
| db_create_test1 |
| db_create_test2 |
| create_test12   |
+-----------------+
3 rows in set (0.001 sec)

MariaDB [testdatabase]&gt; SELECT name FROM tasks WHERE name REGEXP &quot;test[a-z0-9]{2,3}&quot;;
+---------------+
| name          |
+---------------+
| create_test12 |
+---------------+
1 row in set (0.001 sec)
</code></pre>
<h3 id="928-定位符"><a class="header" href="#928-定位符">9.2.8 定位符</a></h3>
<p>为了匹配特定位置的文本，需要使用定位符。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">元字符</th><th style="text-align: center">说明</th></tr></thead><tbody>
<tr><td style="text-align: center">^</td><td style="text-align: center">文本的开始</td></tr>
<tr><td style="text-align: center">$</td><td style="text-align: center">文本的结尾</td></tr>
<tr><td style="text-align: center">[[:&lt;:]]</td><td style="text-align: center">词的开始</td></tr>
<tr><td style="text-align: center">[[:&gt;:]]</td><td style="text-align: center">词的结尾</td></tr>
</tbody></table>
</div>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT * FROM tasks;
+----+-----------------+--------+-------+---------+-------------+--------+
| Id | Name            | Result | Fault | Correct | Description | Parent |
+----+-----------------+--------+-------+---------+-------------+--------+
|  1 | db_create_test  |      1 |     1 |       0 | NULL        |        |
|  2 | db_create_test1 |      1 |     0 |       1 |             | NULL   |
|  3 | db_create_test2 |      0 |     1 |       0 | NULL        | NULL   |
|  4 | fake_case_1     |      1 |     0 |       0 |             |        |
|  5 | create_test12   |      1 |     2 |       0 | NULL        | NULL   |
+----+-----------------+--------+-------+---------+-------------+--------+
5 rows in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT name FROM tasks WHERE name REGEXP &quot;^[a-d]{2}&quot;;
+-----------------+
| name            |
+-----------------+
| db_create_test  |
| db_create_test1 |
| db_create_test2 |
+-----------------+
3 rows in set (0.001 sec)

MariaDB [testdatabase]&gt; SELECT * FROM tasks;
+----+-----------------+--------+-------+---------+-------------+--------+
| Id | Name            | Result | Fault | Correct | Description | Parent |
+----+-----------------+--------+-------+---------+-------------+--------+
|  1 | db_create_test  |      1 |     1 |       0 | NULL        |        |
|  2 | db_create_test1 |      1 |     0 |       1 |             | NULL   |
|  3 | db_create_test2 |      0 |     1 |       0 | NULL        | NULL   |
|  4 | fake_case_1     |      1 |     0 |       0 |             |        |
|  5 | create_test12   |      1 |     2 |       0 | NULL        | NULL   |
+----+-----------------+--------+-------+---------+-------------+--------+
5 rows in set (0.001 sec)

MariaDB [testdatabase]&gt; SELECT name FROM tasks WHERE name REGEXP &quot;[[:digit:]_]{2}$&quot;;
+---------------+
| name          |
+---------------+
| fake_case_1   |
| create_test12 |
+---------------+
2 rows in set (0.001 sec)
</code></pre>
<p><strong>^的双重用途</strong>  ^有两种用法。在集合中（用[和]定义，也就是^出现在方括号里面的时候，表示否定），用它来否定该集合，否则，用来指串的开始处。</p>
<p><strong>使REGEXP起类似LIKE的作用</strong>  利用定位符，通过用^开始每个表达式，用$结束每个表达式，可以使REGEXP的作用与LIKE一样。</p>
<p><strong>简单的正则表达式测试</strong>  可以在不使用数据库表的情况下用SELECT来测试正则表达式。REGEXP检查总是返回0（没有匹配）或1（匹配）。可以用带文字串的REGEXP来测试表达式，并试验它们。相应的语法如<code>SELECT 'hello' REGEXP '[0-9]';</code>这个例子显然将返回0（因为文本hello中没有数字）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="10-创建计算字段"><a class="header" href="#10-创建计算字段">10 创建计算字段</a></h1>
<h2 id="101-计算字段"><a class="header" href="#101-计算字段">10.1 计算字段</a></h2>
<p><strong>字段（field）</strong> 基本上与列（column）的意思相同，经常互换使用，不过数据库列一般称为列，而术语字段通常用在计算字段的连接上。</p>
<p><strong>客户机与服务器的格式</strong>  可在SQL语句内完成的许多转换和格式化工作都可以直接在客户机应用程序内完成。但一般来说，在数据库服务器上完成这些操作比在客户机中完成要快得多，因为DBMS是设计来快速有效地完成这种处理的。</p>
<h2 id="102-拼接字段"><a class="header" href="#102-拼接字段">10.2 拼接字段</a></h2>
<p>在MySQL的SELECT语句中，可使用Concat()函数来拼接两个列。</p>
<p><strong>拼接（concatenate）</strong> 将值联结到一起构成单个值。</p>
<p><strong>MySQL的不同之处</strong>  多数DBMS使用+或||来实现拼接，MySQL则使用Concat()函数来实现。当把SQL语句转换成MySQL语句时一定要把这个区别铭记在心。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT * FROM vendors;
+-----------+---------------+
| name      | location      |
+-----------+---------------+
| alphabet  | mountain view |
| amazon    | seattle       |
| amd       | california    |
| apple     | california    |
| intel     | california    |
| meta      | california    |
| microsoft | washington    |
| nvidia    | california    |
| tesla     | california    |
+-----------+---------------+
9 rows in set (0.001 sec)

MariaDB [testdatabase]&gt; SELECT Concat(name, ' (', location, ')') FROM vendors ORDER BY name;
+-----------------------------------+
| Concat(name, ' (', location, ')') |
+-----------------------------------+
| alphabet (mountain view)          |
| amazon (seattle)                  |
| amd (california)                  |
| apple (california)                |
| intel (california)                |
| meta (california)                 |
| microsoft (washington)            |
| nvidia (california)               |
| tesla (california)                |
+-----------------------------------+
9 rows in set (0.000 sec)
</code></pre>
<p><strong>Concat()拼接串</strong>，即把多个串连接起来形成一个较长的串。Concat()需要一个或多个指定的串，各个串之间用逗号分隔。上面的SELECT语句连接以下4个元素成一个列：</p>
<ul>
<li>存储在name列中的名字</li>
<li>包含一个空格和一个左圆括号的串</li>
<li>存储在location列中的位置</li>
<li>包含一个右圆括号的串</li>
</ul>
<p><strong>Trim函数</strong>  MySQL除了支持RTrim()（正如刚才所见，它去掉串右边的空格），还支持LTrim()（去掉串左边的空格）以及Trim()（去掉串左右两边的空格）。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT * FROM vendors;
+-----------+---------------+
| name      | location      |
+-----------+---------------+
| alphabet  | mountain view |
| amazon    | seattle       |
| amd       | california    |
| apple     | california    |
| intel     | california    |
| meta      | california    |
| microsoft | washington    |
| nvidia    | california    |
| tesla     | california    |
+-----------+---------------+
9 rows in set (0.001 sec)

MariaDB [testdatabase]&gt; SELECT Concat(name, LTrim(' ('), location, ')') FROM vendors ORDER BY name;
+------------------------------------------+
| Concat(name, LTrim(' ('), location, ')') |
+------------------------------------------+
| alphabet(mountain view)                  |
| amazon(seattle)                          |
| amd(california)                          |
| apple(california)                        |
| intel(california)                        |
| meta(california)                         |
| microsoft(washington)                    |
| nvidia(california)                       |
| tesla(california)                        |
+------------------------------------------+
9 rows in set (0.001 sec)
</code></pre>
<p><strong>使用别名</strong></p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT * FROM vendors;
+-----------+---------------+
| name      | location      |
+-----------+---------------+
| alphabet  | mountain view |
| amazon    | seattle       |
| amd       | california    |
| apple     | california    |
| intel     | california    |
| meta      | california    |
| microsoft | washington    |
| nvidia    | california    |
| tesla     | california    |
+-----------+---------------+
9 rows in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT Concat(name,' (',location,')') AS vend_title FROM vendors;
+--------------------------+
| vend_title               |
+--------------------------+
| alphabet (mountain view) |
| amazon (seattle)         |
| amd (california)         |
| apple (california)       |
| intel (california)       |
| meta (california)        |
| microsoft (washington)   |
| nvidia (california)      |
| tesla (california)       |
+--------------------------+
9 rows in set (0.001 sec)
</code></pre>
<p><strong>别名的其他用途</strong>  别名还有其他用途。常见的用途包括在实际的表列名包含不符合规定的字符（如空格）时重新命名它，在原来的名字含混或容易误解时扩充它，等等。</p>
<p><strong>导出列</strong>  别名有时也称为导出列（derived column），不管称为什么，它们所代表的都是相同的东西。</p>
<h2 id="103-执行算术计算"><a class="header" href="#103-执行算术计算">10.3 执行算术计算</a></h2>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT * FROM orders;
+---------+----------+------------+
| prod_id | quantity | item_price |
+---------+----------+------------+
| ANV01   |       10 |       5.99 |
| ANV02   |        3 |       9.99 |
| FB      |        1 |         10 |
| YNT2    |        5 |         10 |
+---------+----------+------------+
4 rows in set (0.001 sec)

MariaDB [testdatabase]&gt; SELECT prod_id,quantity,item_price,quantity*item_price AS expand_price FROM orders;
+---------+----------+------------+--------------------+
| prod_id | quantity | item_price | expand_price       |
+---------+----------+------------+--------------------+
| ANV01   |       10 |       5.99 |  59.89999771118164 |
| ANV02   |        3 |       9.99 | 29.969999313354492 |
| FB      |        1 |         10 |                 10 |
| YNT2    |        5 |         10 |                 50 |
+---------+----------+------------+--------------------+
4 rows in set (0.001 sec)
</code></pre>
<p><strong>MySql的float存在精度问题</strong> 浮点数在计算机中的内部表示方式是使用有限的二进制位数进行近似存储的。由于浮点数的精度是有限的，当我们进行一些复杂的计算时，可能会导小数部分的精度损失。</p>
<p><strong>解决方法</strong></p>
<ul>
<li>
<p>使用DECIMAL类型：DECIMAL(8,2)指定了存储8位数字，小数部分保留2位</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; DESCRIBE orders;
+------------+--------------+------+-----+---------+-------+
| Field      | Type         | Null | Key | Default | Extra |
+------------+--------------+------+-----+---------+-------+
| prod_id    | varchar(50)  | NO   | PRI | NULL    |       |
| quantity   | int(11)      | NO   |     | NULL    |       |
| item_price | decimal(8,2) | NO   |     | NULL    |       |
+------------+--------------+------+-----+---------+-------+
3 rows in set (0.002 sec)

MariaDB [testdatabase]&gt; SELECT prod_id,quantity,item_price,quantity*item_price AS expand_price FROM orders;
+---------+----------+------------+--------------+
| prod_id | quantity | item_price | expand_price |
+---------+----------+------------+--------------+
| ANV01   |       10 |       5.99 |        59.90 |
| ANV02   |        3 |       9.99 |        29.97 |
| FB      |        1 |      10.00 |        10.00 |
| YNT2    |        5 |      10.00 |        50.00 |
+---------+----------+------------+--------------+
4 rows in set (0.001 sec)
</code></pre>
</li>
<li>
<p>使用ROUND函数：ROUND函数可以将计算结果四舍五入到指定的精度</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; DESCRIBE orders;
+------------+-------------+------+-----+---------+-------+
| Field      | Type        | Null | Key | Default | Extra |
+------------+-------------+------+-----+---------+-------+
| prod_id    | varchar(50) | NO   | PRI | NULL    |       |
| quantity   | int(11)     | NO   |     | NULL    |       |
| item_price | float       | NO   |     | NULL    |       |
+------------+-------------+------+-----+---------+-------+
3 rows in set (0.001 sec)

MariaDB [testdatabase]&gt; SELECT prod_id,quantity,item_price,ROUND(quantity*item_price,2) AS expand_price FROM orders;
+---------+----------+------------+--------------+
| prod_id | quantity | item_price | expand_price |
+---------+----------+------------+--------------+
| ANV01   |       10 |       5.99 |        59.90 |
| ANV02   |        3 |       9.99 |        29.97 |
| FB      |        1 |         10 |        10.00 |
| YNT2    |        5 |         10 |        50.00 |
+---------+----------+------------+--------------+
4 rows in set (0.000 sec)
</code></pre>
</li>
<li>
<p>使用CAST函数：CAST将一个值转换为指定的数据类型。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; DESCRIBE orders;
+------------+-------------+------+-----+---------+-------+
| Field      | Type        | Null | Key | Default | Extra |
+------------+-------------+------+-----+---------+-------+
| prod_id    | varchar(50) | NO   | PRI | NULL    |       |
| quantity   | int(11)     | NO   |     | NULL    |       |
| item_price | float       | NO   |     | NULL    |       |
+------------+-------------+------+-----+---------+-------+
3 rows in set (0.001 sec)

MariaDB [testdatabase]&gt; SELECT prod_id,quantity,item_price,CAST(quantity*item_price AS DECIMAL(8,2)) AS expand_price FROM orders;
+---------+----------+------------+--------------+
| prod_id | quantity | item_price | expand_price |
+---------+----------+------------+--------------+
| ANV01   |       10 |       5.99 |        59.90 |
| ANV02   |        3 |       9.99 |        29.97 |
| FB      |        1 |         10 |        10.00 |
| YNT2    |        5 |         10 |        50.00 |
+---------+----------+------------+--------------+
4 rows in set (0.001 sec)
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="11-使用数据处理函数"><a class="header" href="#11-使用数据处理函数">11 使用数据处理函数</a></h1>
<h2 id="112-使用函数"><a class="header" href="#112-使用函数">11.2 使用函数</a></h2>
<p>大多数SQL实现支持以下类型的函数</p>
<ul>
<li>用于处理文本串(如删除或填充值，转换值为大小写)的文本函数。</li>
<li>用于在数值数据上进行算术操作(如返回绝对值，进行代数运算)的数值函数。</li>
<li>用于处理日期的时间值并从这些值中提取特定成分(例如，返回两个日期之差，检查日期有效性等)的日期和时间函数。</li>
<li>返回DBMS正使用的特殊信息(如返回用户登录信息，检查版本细节)的系统函数。</li>
</ul>
<h2 id="1121-文本处理函数"><a class="header" href="#1121-文本处理函数">11.2.1 文本处理函数</a></h2>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT name FROM vendors LIMIT 3;
+----------+
| name     |
+----------+
| alphabet |
| amazon   |
| amd      |
+----------+
3 rows in set (0.001 sec)

MariaDB [testdatabase]&gt; SELECT name,Upper(name) AS name_upcase FROM vendors LIMIT 3;
+----------+-------------+
| name     | name_upcase |
+----------+-------------+
| alphabet | ALPHABET    |
| amazon   | AMAZON      |
| amd      | AMD         |
+----------+-------------+
3 rows in set (0.001 sec)
</code></pre>
<p>正如所见，Upper将文本转换为大写。</p>
<h4 id="常用的文本处理函数"><a class="header" href="#常用的文本处理函数">常用的文本处理函数</a></h4>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">函数</th><th style="text-align: center">说明</th></tr></thead><tbody>
<tr><td style="text-align: center">Left(str,length)</td><td style="text-align: center">返回str左边数起length长度的字符</td></tr>
<tr><td style="text-align: center">Length(str)</td><td style="text-align: center">返回str的长度</td></tr>
<tr><td style="text-align: center">Locate(sub,str,start)</td><td style="text-align: center">找出str中start位置开始检查sub子串的位置，默认从1开始</td></tr>
<tr><td style="text-align: center">Lower(str)</td><td style="text-align: center">将串转换为小写</td></tr>
<tr><td style="text-align: center">LTrim(str)</td><td style="text-align: center">去掉串左边的空格</td></tr>
<tr><td style="text-align: center">Right(str,length)</td><td style="text-align: center">返回串右边的字符</td></tr>
<tr><td style="text-align: center">RTrim(str)</td><td style="text-align: center">去掉串右边的空格</td></tr>
<tr><td style="text-align: center">Soundex(str)</td><td style="text-align: center">返回串的SOUNDEX值</td></tr>
<tr><td style="text-align: center">SubString(str,start,length)</td><td style="text-align: center">返回str从start开始length长度的子串</td></tr>
<tr><td style="text-align: center">Upper(str)</td><td style="text-align: center">将串转换为大写</td></tr>
</tbody></table>
</div>
<p>SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法。SOUNDEX考虑了类似的发音字符和音节，使得能对串进行发音比较而不是字母比较。虽然SOUNDEX不是SQL概念，但MySQL（就像多数DBMS一样）都提供对SOUNDEX的支持。</p>
<h3 id="1122-日期和时间处理函数"><a class="header" href="#1122-日期和时间处理函数">11.2.2 日期和时间处理函数</a></h3>
<p><strong>常用日期和时间处理函数</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">函数</th><th style="text-align: center">说明</th></tr></thead><tbody>
<tr><td style="text-align: center">AddDate(date,INTERVALvalueunit)</td><td style="text-align: center">增加一个日期（天、周等）</td></tr>
<tr><td style="text-align: center">AddTime()</td><td style="text-align: center">增加一个时间（时、分等）</td></tr>
<tr><td style="text-align: center">CurDate()</td><td style="text-align: center">返回当前日期</td></tr>
<tr><td style="text-align: center">CurTime()</td><td style="text-align: center">返回当前时间</td></tr>
<tr><td style="text-align: center">Date()</td><td style="text-align: center">返回日期时间的日期部分</td></tr>
<tr><td style="text-align: center">DateDiff(end,start)</td><td style="text-align: center">计算两个日期之差</td></tr>
<tr><td style="text-align: center">Date_Add(date,INTERVALvalueunit)</td><td style="text-align: center">高度灵活的日期运算函数</td></tr>
<tr><td style="text-align: center">Date_Format(date,format)</td><td style="text-align: center">返回一个格式化的日期或时间串</td></tr>
<tr><td style="text-align: center">Day()</td><td style="text-align: center">返回一个日期的天数部分</td></tr>
<tr><td style="text-align: center">DayOfWeek()</td><td style="text-align: center">对于一个日期，返回对应的星期几</td></tr>
<tr><td style="text-align: center">Hour()</td><td style="text-align: center">返回一个时间的小时部分</td></tr>
<tr><td style="text-align: center">Minute()</td><td style="text-align: center">返回一个时间的分钟部分</td></tr>
<tr><td style="text-align: center">Month()</td><td style="text-align: center">返回一个日期的月份部分</td></tr>
<tr><td style="text-align: center">Now()</td><td style="text-align: center">返回当前日期和时间</td></tr>
<tr><td style="text-align: center">Second()</td><td style="text-align: center">返回一个时间的秒部分</td></tr>
<tr><td style="text-align: center">Time()</td><td style="text-align: center">返回一个日期时间的时间部分</td></tr>
<tr><td style="text-align: center">Year()</td><td style="text-align: center">返回一个日期的年份部分</td></tr>
</tbody></table>
</div>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT ADDDATE('2022-03-01', INTERVAL 1 DAY);
+---------------------------------------+
| ADDDATE('2022-03-01', INTERVAL 1 DAY) |
+---------------------------------------+
| 2022-03-02                            |
+---------------------------------------+
1 row in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT ADDDATE('2022-03-01', 1);
+--------------------------+
| ADDDATE('2022-03-01', 1) |
+--------------------------+
| 2022-03-02               |
+--------------------------+
1 row in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT ADDDATE('2022-03-01', -1);
+---------------------------+
| ADDDATE('2022-03-01', -1) |
+---------------------------+
| 2022-02-28                |
+---------------------------+
1 row in set (0.001 sec)

MariaDB [testdatabase]&gt; SELECT ADDDATE('2022-03-01', INTERVAL -1 WEEK);
+-----------------------------------------+
| ADDDATE('2022-03-01', INTERVAL -1 WEEK) |
+-----------------------------------------+
| 2022-02-22                              |
+-----------------------------------------+
1 row in set (0.000 sec)
MariaDB [testdatabase]&gt; SELECT ADDTIME('12:00:00', '03:30:00');
+---------------------------------+
| ADDTIME('12:00:00', '03:30:00') |
+---------------------------------+
| 15:30:00                        |
+---------------------------------+
1 row in set (0.001 sec)

MariaDB [testdatabase]&gt; SELECT ADDTIME('12:00:00', '-03:30:00');
+----------------------------------+
| ADDTIME('12:00:00', '-03:30:00') |
+----------------------------------+
| 08:30:00                         |
+----------------------------------+
1 row in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT CONCAT(CURDATE(), ' ', CURTIME()) AS now;
+---------------------+
| now                 |
+---------------------+
| 2024-03-23 19:02:36 |
+---------------------+
1 row in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT DATE(CURDATE());
+-----------------+
| DATE(CURDATE()) |
+-----------------+
| 2024-03-23      |
+-----------------+
1 row in set (0.002 sec)

MariaDB [testdatabase]&gt; SELECT DATEDIFF(CURDATE(), '2024-03-01');
+-----------------------------------+
| DATEDIFF(CURDATE(), '2024-03-01') |
+-----------------------------------+
|                                22 |
+-----------------------------------+
1 row in set (0.001 sec)

MariaDB [testdatabase]&gt; SELECT DATE_FORMAT('2024-03-01','%Y%m%d');
+------------------------------------+
| DATE_FORMAT('2024-03-01','%Y%m%d') |
+------------------------------------+
| 20240301                           |
+------------------------------------+
1 row in set (0.001 sec)
</code></pre>
<p><strong>需要注意MySQL使用的日期格式，</strong> 无论你什么时候指定一个日期，不管是插入或更新表值还是用WHERE子句进行过滤，日期必须为格式yyyy-mm-dd。</p>
<p><strong>应该总是使用4位数字的年份</strong>  支持2位数字的年份，MySQL处理00-69为2000-2069，处理70-99为1970-1999。虽然它们可能是打算要的年份，但使用完整的4位数字年份更可靠，因为MySQL不必做出任何假定。</p>
<h3 id="1123-数值处理函数"><a class="header" href="#1123-数值处理函数">11.2.3 数值处理函数</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">函数</th><th style="text-align: center">说明</th></tr></thead><tbody>
<tr><td style="text-align: center">Abs()</td><td style="text-align: center">返回一个数的绝对值</td></tr>
<tr><td style="text-align: center">Cos()</td><td style="text-align: center">返回一个角度的余弦</td></tr>
<tr><td style="text-align: center">Exp()</td><td style="text-align: center">返回一个数的指数值</td></tr>
<tr><td style="text-align: center">Mod()</td><td style="text-align: center">返回除操作的余数</td></tr>
<tr><td style="text-align: center">Pi()</td><td style="text-align: center">返回圆周率</td></tr>
<tr><td style="text-align: center">Rand()</td><td style="text-align: center">返回一个随机数</td></tr>
<tr><td style="text-align: center">Sin()</td><td style="text-align: center">返回一个角度的正弦</td></tr>
<tr><td style="text-align: center">Sqrt()</td><td style="text-align: center">返回一个数的平方根</td></tr>
<tr><td style="text-align: center">Tan()</td><td style="text-align: center">返回一个角度的正切</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="12-汇总数据"><a class="header" href="#12-汇总数据">12 汇总数据</a></h1>
<h2 id="121-聚集函数"><a class="header" href="#121-聚集函数">12.1 聚集函数</a></h2>
<p><strong>聚集函数</strong> 运行在行组上，计算和返回单个值的函数</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">函数</th><th style="text-align: center">说明</th></tr></thead><tbody>
<tr><td style="text-align: center">AVG()</td><td style="text-align: center">返回某列的平均值</td></tr>
<tr><td style="text-align: center">COUNT()</td><td style="text-align: center">返回某列的行数</td></tr>
<tr><td style="text-align: center">MAX()</td><td style="text-align: center">返回某列的最大值</td></tr>
<tr><td style="text-align: center">MIN()</td><td style="text-align: center">返回某列的最小值</td></tr>
<tr><td style="text-align: center">SUM()</td><td style="text-align: center">返回某列的值之和</td></tr>
</tbody></table>
</div>
<h3 id="1211-avg函数"><a class="header" href="#1211-avg函数">12.1.1 AVG函数</a></h3>
<p><strong>只用于单个列</strong>  AVG()只能用来确定特定数值列的平均值，而且列名必须作为函数参数给出。为了获得多个列的平均值，必须使用多个AVG()函数。</p>
<p><strong>NULL值</strong>  AVG()函数忽略列值为NULL的行。</p>
<h3 id="1212-count函数"><a class="header" href="#1212-count函数">12.1.2 COUNT函数</a></h3>
<p>COUNT函数有两种使用方式：</p>
<ul>
<li>使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值。</li>
<li>使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值。</li>
</ul>
<h3 id="1213-max函数"><a class="header" href="#1213-max函数">12.1.3 MAX函数</a></h3>
<p><strong>对非数值数据使用MAX()</strong>  虽然MAX()一般用来找出最大的数值或日期值，但MySQL允许将它用来返回任意列中的最大值，包括返回文本列中的最大值。在用于文本数据时，如果数据按相应的列排序，则MAX()返回最后一行。</p>
<p><strong>NULL值</strong>  MAX()函数忽略列值为NULL的行。</p>
<h3 id="1214-min函数"><a class="header" href="#1214-min函数">12.1.4 MIN函数</a></h3>
<p><strong>对非数值数据使用MIN()</strong>  MIN()函数与MAX()函数类似，MySQL允许将它用来返回任意列中的最小值，包括返回文本列中的最小值。在用于文本数据时，如果数据按相应的列排序，则MIN()返回最前面的行。</p>
<p><strong>NULL值</strong>  MAX()函数忽略列值为NULL的行。</p>
<h3 id="1215-sum函数"><a class="header" href="#1215-sum函数">12.1.5 SUM函数</a></h3>
<p><strong>NULL值</strong>  SUM()函数忽略列值为NULL的行。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT * FROM tasks;
+----+-----------------+--------+-------+---------+-------------+--------+
| Id | Name            | Result | Fault | Correct | Description | Parent |
+----+-----------------+--------+-------+---------+-------------+--------+
|  1 | db_create_test  |      1 |     1 |       0 | NULL        |        |
|  2 | db_create_test1 |      1 |     0 |       1 |             | NULL   |
|  3 | db_create_test2 |      0 |     1 |       0 | NULL        | NULL   |
|  4 | fake_case_1     |      1 |     0 |       0 |             |        |
|  5 | create_test12   |      1 |     2 |       0 | NULL        | NULL   |
+----+-----------------+--------+-------+---------+-------------+--------+
5 rows in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT SUM(result*fault) FROM tasks;
+-------------------+
| SUM(result*fault) |
+-------------------+
|                 3 |
+-------------------+
1 row in set (0.001 sec)
</code></pre>
<h2 id="122-聚集不同值"><a class="header" href="#122-聚集不同值">12.2 聚集不同值</a></h2>
<p><strong>以上5个聚集函数都可以做如下使用</strong></p>
<ul>
<li>对所有的行执行计算，指定ALL参数或不给参数（因为ALL是默认行为）；</li>
<li>只包含不同的值，指定<em>DISTINCT</em>参数。</li>
</ul>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT * FROM tasks;
+----+-----------------+--------+-------+---------+-------------+--------+
| Id | Name            | Result | Fault | Correct | Description | Parent |
+----+-----------------+--------+-------+---------+-------------+--------+
|  1 | db_create_test  |      1 |     1 |       0 | NULL        |        |
|  2 | db_create_test1 |      1 |     0 |       1 |             | NULL   |
|  3 | db_create_test2 |      0 |     1 |       0 | NULL        | NULL   |
|  4 | fake_case_1     |      1 |     0 |       0 |             |        |
|  5 | create_test12   |      1 |     2 |       0 | NULL        | NULL   |
+----+-----------------+--------+-------+---------+-------------+--------+
5 rows in set (0.001 sec)

MariaDB [testdatabase]&gt; SELECT SUM(result) FROM tasks;
+-------------+
| SUM(result) |
+-------------+
|           4 |
+-------------+
1 row in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT SUM(DISTINCT result) FROM tasks;
+----------------------+
| SUM(DISTINCT result) |
+----------------------+
|                    1 |
+----------------------+
1 row in set (0.001 sec)
</code></pre>
<p>DISTINCT不能用于COUNT(*)，因此不允许使用COUNT（DISTINCT），否则会产生错误。类似地，DISTINCT必须使用列名，不能用于计算或表达式。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="13-数据分组"><a class="header" href="#13-数据分组">13 数据分组</a></h1>
<h2 id="132-创建分组"><a class="header" href="#132-创建分组">13.2 创建分组</a></h2>
<p>分组是在SELECT语句的GROUP BY子句中建立的。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT * FROM products;
+----+-----------+---------+
| id | vend_name | product |
+----+-----------+---------+
|  1 | apple     | macbook |
|  2 | apple     | ipad    |
|  3 | apple     | iphone  |
|  4 | microsoft | surface |
|  5 | microsoft | windows |
|  6 | google    | gemini  |
+----+-----------+---------+
6 rows in set (0.001 sec)

MariaDB [testdatabase]&gt; SELECT vend_name,COUNT(*) AS num_products FROM products GROUP BY vend_name;
+-----------+--------------+
| vend_name | num_products |
+-----------+--------------+
| apple     |            3 |
| google    |            1 |
| microsoft |            2 |
+-----------+--------------+
3 rows in set (0.001 sec)
</code></pre>
<p>在具体使用GROUP BY子句前，需要知道一些重要的规定</p>
<ul>
<li>GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制。</li>
<li>如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。</li>
<li>GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。 </li>
<li>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。</li>
</ul>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT * FROM products;
+----+-----------+---------+
| id | vend_name | product |
+----+-----------+---------+
|  1 | apple     | macbook |
|  2 | apple     | ipad    |
|  3 | apple     | iphone  |
|  4 | microsoft | surface |
|  5 | microsoft | windows |
|  6 | google    | gemini  |
|  7 | google    | NULL    |
+----+-----------+---------+
7 rows in set (0.001 sec)

MariaDB [testdatabase]&gt; SELECT vend_name,COUNT(*) AS num_products FROM products GROUP BY vend_name;
+-----------+--------------+
| vend_name | num_products |
+-----------+--------------+
| apple     |            3 |
| google    |            2 |
| microsoft |            2 |
+-----------+--------------+
3 rows in set (0.001 sec)

MariaDB [testdatabase]&gt; SELECT vend_name,COUNT(*) AS num_products FROM products GROUP BY vend_name WITH ROLLUP;
+-----------+--------------+
| vend_name | num_products |
+-----------+--------------+
| apple     |            3 |
| google    |            2 |
| microsoft |            2 |
| NULL      |            7 |
+-----------+--------------+
4 rows in set (0.001 sec)
</code></pre>
<h2 id="133-过滤分组"><a class="header" href="#133-过滤分组">13.3 过滤分组</a></h2>
<p><strong>HAVING支持所有WHERE操作符</strong> 在第6章和第7章中，我们学习了WHERE子句的条件（包括通配符条件和带多个操作符的子句）。所学过的有关WHERE的所有这些技术和选项都适用于HAVING。它们的句法是相同的，只是关键字有差别。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT vend_name,COUNT(*) AS num_products FROM products GROUP BY vend_name;
+-----------+--------------+
| vend_name | num_products |
+-----------+--------------+
| apple     |            3 |
| google    |            2 |
| microsoft |            2 |
+-----------+--------------+
3 rows in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT vend_name,COUNT(*) AS num_products FROM products GROUP BY vend_name HAVING COUNT(*)&gt;2;
+-----------+--------------+
| vend_name | num_products |
+-----------+--------------+
| apple     |            3 |
+-----------+--------------+
1 row in set (0.001 sec)
</code></pre>
<p><strong>HAVING和WHERE的差别</strong>  这里有另一种理解方法，WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤。这是一个重要的区别，WHERE排除的行不包括在分组中。这可能会改变计算值，从而影响HAVING子句中基于这些值过滤掉的分组。</p>
<h2 id="134-分组和排序"><a class="header" href="#134-分组和排序">13.4 分组和排序</a></h2>
<p><strong>ORDER BY</strong>和<strong>GROUP BY</strong>的区别</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">ORDER BY</th><th style="text-align: center">GROUP BY</th></tr></thead><tbody>
<tr><td style="text-align: center">排序产生的输出</td><td style="text-align: center">分组行。但输出可能不是分组的顺序</td></tr>
<tr><td style="text-align: center">任意列都可以使用(甚至非选择的列也可以使用)</td><td style="text-align: center">只可能使用选择列或表达式列，而且必须使用每个选择列表达式</td></tr>
</tbody></table>
</div>
<p><strong>不要忘记ORDER BY</strong>  一般在使用GROUP BY子句时，应该也给出ORDER BY子句。这是保证数据正确排序的唯一方法。千万不要仅依赖GROUP BY排序数据。</p>
<h2 id="135-select子句顺序"><a class="header" href="#135-select子句顺序">13.5 SELECT子句顺序</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">子句</th><th style="text-align: center">说明</th><th style="text-align: center">是否必须使用</th></tr></thead><tbody>
<tr><td style="text-align: center">SELECT</td><td style="text-align: center">要返回的列或者表达式</td><td style="text-align: center">是</td></tr>
<tr><td style="text-align: center">FROM</td><td style="text-align: center">从中检索数据中的表</td><td style="text-align: center">仅在从表选择数据时使用</td></tr>
<tr><td style="text-align: center">WHERE</td><td style="text-align: center">行级过滤</td><td style="text-align: center">否</td></tr>
<tr><td style="text-align: center">GROUP BY</td><td style="text-align: center">分组</td><td style="text-align: center">仅在按组计算聚集时使用</td></tr>
<tr><td style="text-align: center">HAVING</td><td style="text-align: center">组级过滤</td><td style="text-align: center">否</td></tr>
<tr><td style="text-align: center">ORDER BY</td><td style="text-align: center">给输出排序</td><td style="text-align: center">否</td></tr>
<tr><td style="text-align: center">LIMIT</td><td style="text-align: center">要检索的行数</td><td style="text-align: center">否</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="14-使用子查询"><a class="header" href="#14-使用子查询">14 使用子查询</a></h1>
<h2 id="142-利用子查询进行过滤"><a class="header" href="#142-利用子查询进行过滤">14.2 利用子查询进行过滤</a></h2>
<p>SQL允许创建子查询（subquery），即嵌套在其他查询中的查询。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = 'TNT2');
+-----------+
|  cust_id  |
+-----------+
|    10001  |
|    10004  |
+-----------+
2 rows in set (0.001 sec)
</code></pre>
<p>在WHERE子句中使用子查询能够编写出功能很强并且很灵活的SQL语句。对于能嵌套的子查询的数目没有限制，不过在实际使用时由于性能的限制，不能嵌套太多的子查询。</p>
<p><strong>列必须匹配</strong>  在WHERE子句中使用子查询（如这里所示），应该保证SELECT语句具有与WHERE子句中相同数目的列。通常，子查询将返回单个列并且与单个列匹配，但如果需要也可以使用多个列。</p>
<h2 id="143-作为计算字段使用子查询"><a class="header" href="#143-作为计算字段使用子查询">14.3 作为计算字段使用子查询</a></h2>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT cust_name,cust_state,(SELECT COUNT(*) FROM orders WHERE orders.cust_id = customers.cust_id) AS orders FROM customers ORDER BY cust_name;
+-----------------+------------+--------+
| cust_name       | cust_state | orders |
+-----------------+------------+--------+
| Coyote Inc.     | MI         |      2 |
| E Fudd          | IL         |      1 |
| Mouse House     | OH         |      0 |
| Wascals         | IN         |      1 |
| Yosemite Place  | AZ         |      1 |
+-----------------+------------+--------+
5 rows in set (0.001 sec)
</code></pre>
<p>子查询中的WHERE子句与前面使用的WHERE子句稍有不同，因为它使用了完全限定列名（在第4章中首次提到）。上面的语句告诉SQL比较orders表中的cust_id与当前正从customers表中检索的cust_id。</p>
<p>这种类型的子查询称为相关子查询。任何时候只要列名可能有多义性，就必须使用这种语法（表名和列名由一个句点分隔）。</p>
<p><strong>逐渐增加子查询来建立查询</strong>  用子查询测试和调试查询很有技巧性，特别是在这些语句的复杂性不断增加的情况下更是如此。用子查询建立（和测试）查询的最可靠的方法是逐渐进行，这与MySQL处理它们的方法非常相同。首先，建立和测试最内层的查询。然后，用硬编码数据建立和测试外层查询，并且仅在确认它正常后才嵌入子查询。这时，再次测试它。对于要增加的每个查询，重复这些步骤。这样做仅给构造查询增加了一点点时间，但节省了以后（找出查询为什么不正常）的大量时间，并且极大地提高了查询一开始就正常工作的可能性。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="15-联结表"><a class="header" href="#15-联结表">15 联结表</a></h1>
<h2 id="151-联结"><a class="header" href="#151-联结">15.1 联结</a></h2>
<h3 id="1511-关系表"><a class="header" href="#1511-关系表">15.1.1 关系表</a></h3>
<p><strong>外键（foreign key）</strong> 外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。</p>
<p>这样做的好处是：</p>
<ul>
<li>外键指向的表中的信息变更的时候只需要做一份修改</li>
<li>存储的数据没有重复</li>
</ul>
<p>因此，关系型数据库的可伸缩性远比非关系型数据库好。</p>
<p><strong>可伸缩性（scale）</strong> 能够适应不断增加的工作量而不失败。设计良好的数据库或应用程序称之为可伸缩性好(scale well)。</p>
<h3 id="1512-为什么要使用联结"><a class="header" href="#1512-为什么要使用联结">15.1.2 为什么要使用联结</a></h3>
<p>分解数据为多个表能更有效地存储，更方便地处理，并且具有更大的可伸缩性。但这些好处是有代价的。—— 查询变的复杂。</p>
<p>联结是一种机制，用来在一条SELECT语句中关联表，因此称之为联结。使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行。</p>
<p><strong>维护引用完整性</strong>  重要的是，要理解联结不是物理实体。换句话说，它在实际的数据库表中不存在。联结由MySQL根据需要建立，它存在于查询的执行当中。(参阅21章) </p>
<h2 id="152-创建联结"><a class="header" href="#152-创建联结">15.2 创建联结</a></h2>
<pre><code class="language-SQL">示例
</code></pre>
<h3 id="1521-where子句的重要性"><a class="header" href="#1521-where子句的重要性">15.2.1 WHERE子句的重要性</a></h3>
<p>利用WHERE子句建立联结关系似乎有点奇怪，但实际上，有一个很充分的理由。请记住，在一条SELECT语句中联结几个表时，相应的关系是在运行中构造的。在数据库表的定义中不存在能指示MySQL如何对表进行联结的东西。你必须自己做这件事情。在联结两个表时，你实际上做的是将第一个表中的每一行与第二个表中的每一行配对。WHERE子句作为过滤条件，它只包含那些匹配给定条件（这里是联结条件）的行。没有WHERE子句，第一个表中的每个行将与第二个表中的每个行配对，而不管它们逻辑上是否可以配在一起。</p>
<p><strong>笛卡儿积（cartesian product）</strong> 由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。</p>
<p><strong>不要忘了WHERE子句</strong> 应该保证所有联结都有WHERE子句，否则MySQL将返回比想要的数据多得多的数据。同理，应该保证WHERE子句的正确性。不正确的过滤条件将导致MySQL返回不正确的数据。</p>
<h3 id="1522-内部联结"><a class="header" href="#1522-内部联结">15.2.2 内部联结</a></h3>
<p>目前为止所用的联结称为等值联结（equijoin），它基于两个表之间的相等测试。这种联结也称为内部联结。WHERE语法可以用INNER JOIN语法替换。</p>
<p><strong>使用哪种语法</strong> ANSI SQL规范首选INNER JOIN语法。此外，尽管使用WHERE子句定义联结的确比较简单，但是使用明确的联结语法能够确保不会忘记联结条件，有时候这样做也能影响性能。</p>
<h3 id="1523-联结多个表"><a class="header" href="#1523-联结多个表">15.2.3 联结多个表</a></h3>
<p>在WHERE语法中，可以通过在FROM添加多个表，在WHERE后面用AND拼接多个条件来联结多个表。</p>
<p><strong>性能考虑</strong> MySQL在运行时关联指定的每个表以处理联结。这种处理可能是非常耗费资源的，因此应该仔细，不要联结不必要的表。联结的表越多，性能下降越厉害。</p>
<p><strong>多做实验</strong> 为执行任一给定的SQL操作，一般存在不止一种方法。很少有绝对正确或绝对错误的方法。性能可能会受操作类型、表中数据量、是否存在索引或键以及其他一些条件的影响。因此，有必要对不同的选择机制进行实验，以找出最适合具体情况的方法。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="16-创建高级联结"><a class="header" href="#16-创建高级联结">16 创建高级联结</a></h1>
<h2 id="162-使用不同类型的联结"><a class="header" href="#162-使用不同类型的联结">16.2 使用不同类型的联结</a></h2>
<p>之前接触到的INNER JOIN是称为内部联结或等值联结（equijoin）的简单联结。</p>
<h3 id="1621-自联结"><a class="header" href="#1621-自联结">16.2.1 自联结</a></h3>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT p1.prod_id, p1.prod_name FROM products AS p1, products AS p2 WHERE p1.vend_id = p2.vend_id AND p2.prod_id = 'DTNTR';
+---------+----------------+
| prod_id | prod_name      |
+---------+----------------+
| DTNTR   | Detonator      |
| FB      | Bird seed      |
| FC      | Carrots        |
| SAFE    | Safe           |
| SLING   | Sling          |
| TNT1    | TNT (1 stick)  |
| TNT2    | TNT (5 sticks) |
+---------+----------------+
7 rows in set (0.001 sec)
</code></pre>
<p>此查询中需要的两个表实际上是相同的表，products表在FROM子句中出现了两次。虽然这是完全合法的，但对products的引用具有二义性，因为MySQL不知道你引用的是products表中的哪个实例。</p>
<p>为解决此问题，使用了表别名。如果不这样，MySQL将返回错误，因为分别存在两个名为prod_id、prod_name的列。MySQL不知道想要的是哪一个表中的列（即使它们事实上是同一个列，但MySQL不知道他们是同一个表）。</p>
<p><strong>用自联结而不用子查询</strong>  自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。虽然最终的结果是相同的，但有时候处理联结远比处理子查询快得多。应该试一下两种方法，以确定哪一种的性能更好。</p>
<h3 id="1622-自然联结"><a class="header" href="#1622-自然联结">16.2.2 自然联结</a></h3>
<p>无论何时对表进行联结，应该至少有一个列出现在不止一个表中（被联结的列）。标准的联结（前一章中介绍的内部联结）返回所有数据，甚至相同的列多次出现。自然联结排除多次出现，使每个列只返回一次。</p>
<p>自然联结是这样一种联结，其中你只能选择那些唯一的列。<em><strong>这一般是通过对表使用通配符（SELECT *），对所有其他表的列使用明确的子集来完成的</strong></em></p>
<h3 id="1623-外部联结"><a class="header" href="#1623-外部联结">16.2.3 外部联结</a></h3>
<p>许多联结将一个表中的行与另一个表中的行相关联。但有时候会需要包含没有关联行的那些行。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT customers.cust_id, orders.order_num FROM customers LEFT OUTER JOIN orders ON customers.cust_id = orders.cust_id;
+---------+-----------+
| cust_id | order_num |
+---------+-----------+
|   10001 |     20005 |
|   10001 |     20009 |
|   10002 |      NULL |
|   10003 |     20006 |
|   10004 |     20007 |
|   10005 |     20008 |
+---------+-----------+
6 rows in set (0.001 sec)
</code></pre>
<p>这条SELECT语句使用了关键字OUTER JOIN来指定联结的类型（而不是在WHERE子句中指定）。与内部联结关联两个表中的行不同的是，外部联结还包括没有关联行的行。在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表）。上面的例子使用LEFT OUTER JOIN从FROM子句的左边表（customers表）中选择所有行。</p>
<p><strong>没有*=操作符</strong>  MySQL不支持简化字符*=和=*的使用，这两种操作符在其他DBMS中是很流行的。</p>
<h1 id="163-使用带聚集函数的联结"><a class="header" href="#163-使用带聚集函数的联结">16.3 使用带聚集函数的联结</a></h1>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT customers.cust_name,customers.cust_id,COUNT(orders.order_num) AS num_ord FROM customers INNER JOIN orders ON customers.cust_id = orders.cust_id GROUP BY customers.cust_id;
+----------------+---------+---------+
| cust_name      | cust_id | num_ord |
+----------------+---------+---------+
| Coyote Inc.    |   10001 |       2 |
| Wascals        |   10003 |       1 |
| Yosemite Place |   10004 |       1 |
| E Fudd         |   10005 |       1 |
+----------------+---------+---------+
4 rows in set (0.001 sec)
</code></pre>
<p>此SELECT语句使用INNER JOIN将customers和orders表互相关联。GROUP BY子句按客户分组数据，因此，函数调用COUNT(orders.order_num)对每个客户的订单计数，将它作为num_ord返回。</p>
<p>聚集函数也可以方便地与其他联结一起使用</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT customers.cust_name,customers.cust_id,COUNT(orders.order_num) AS num_ord FROM customers LEFT OUTER JOIN orders ON customers.cust_id = orders.cust_id GROUP BY customers.cust_id;
+----------------+---------+---------+
| cust_name      | cust_id | num_ord |
+----------------+---------+---------+
| Coyote Inc.    |   10001 |       2 |
| Mouse House    |   10002 |       0 |
| Wascals        |   10003 |       1 |
| Yosemite Place |   10004 |       1 |
| E Fudd         |   10005 |       1 |
+----------------+---------+---------+
5 rows in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT customers.cust_name,customers.cust_id,COUNT(orders.order_num) AS num_ord FROM customers RIGHT OUTER JOIN orders ON customers.cust_id = orders.cust_id GROUP BY customers.cust_id;
+----------------+---------+---------+
| cust_name      | cust_id | num_ord |
+----------------+---------+---------+
| Coyote Inc.    |   10001 |       2 |
| Wascals        |   10003 |       1 |
| Yosemite Place |   10004 |       1 |
| E Fudd         |   10005 |       1 |
+----------------+---------+---------+
4 rows in set (0.001 sec)
</code></pre>
<p><strong>个人理解</strong> JOIN语句(FROM语句里的表)左边的为左表，右边的为右表。LEFT JOIN保留左表中所有的内容，RIGHT JOIN保留右表中的所有内容。(JOIN中相对于INNER的OUTER关键词一半省略)</p>
<h2 id="164-使用联结和联结条件"><a class="header" href="#164-使用联结和联结条件">16.4 使用联结和联结条件</a></h2>
<p>汇总一下关于联结及其使用的某些要点</p>
<ul>
<li>注意所使用的联结类型。一般我们使用内部联结，但使用外部联结也是有效的。</li>
<li>保证使用正确的联结条件，否则将返回不正确的数据。</li>
<li>应该总是提供联结条件，否则会得出笛卡儿积。</li>
<li>在一个联结中可以包含多个表，甚至对于每个联结可以采用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们前，分别测试每个联结。这将使故障排除更为简单。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="17-组合查询"><a class="header" href="#17-组合查询">17 组合查询</a></h1>
<h2 id="171-组合查询"><a class="header" href="#171-组合查询">17.1 组合查询</a></h2>
<p>多数SQL查询都只包含从一个或多个表中返回数据的单条SELECT语句。MySQL也允许执行多个查询(多条SELECT语句)，并将结果作为单个查询结果集返回。这些组合查询通常称为并(union)或复合查询(compound query)。</p>
<p>有两种基本情况，其中需要使用组合查询</p>
<ul>
<li>在单个查询中从不同的表返回类似结构的数据</li>
<li>对单个表执行多个查询，按单个查询返回数据</li>
</ul>
<p><strong>组合查询和多个WHERE条件</strong> 多数情况下，组合相同表的两个查询完成的工作与具有多个WHERE子句条件的单条查询完成的工作相同。换句话说，任何具有多个WHERE子句的SELECT语句都可以作为一个组合查询给出。这两种技术在不同的查询中性能也不同。因此，应该试一下这两种技术，以确定对特定的查询哪一种性能更好。</p>
<h2 id="172-创建组合查询"><a class="header" href="#172-创建组合查询">17.2 创建组合查询</a></h2>
<p>可用UNION操作符来组合数条SQL查询。利用UNION，可给出多条SELECT语句，将它们的结果组合成单个结果集。</p>
<h3 id="1722-union的规则"><a class="header" href="#1722-union的规则">17.2.2 UNION的规则</a></h3>
<p>UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔(因此，如果组合4条SELECT语句，将要使用3个UNION关键字)。</p>
<p>UNION中的每个查询必须包含相同的列、表达式或聚集函数(不过各个列不需要以相同的次序列出)。</p>
<p>列数据类型必须兼容:类型不必完全相同，但必须是DBMS可以隐含地转换的类型(例如，不同的数值类型或不同的日期类型)。</p>
<h3 id="1723-包含或取消重复的行"><a class="header" href="#1723-包含或取消重复的行">17.2.3 包含或取消重复的行</a></h3>
<p>UNION默认会取消重复的行，若要完全的结果，使用UNION ALL即可。</p>
<p>UNION ALL为UNION的一种形式，它可以完成WHERE子句完成不了的工作。如果确实需要每个条件的匹配行全部出现(包括重复行)，则必须使用UNION ALL而不是WHERE。</p>
<h3 id="1724-对组合查询结果排序"><a class="header" href="#1724-对组合查询结果排序">17.2.4 对组合查询结果排序</a></h3>
<p>在用UNION组合查询的时候只能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后。</p>
<p>UNION的组合查询可以应用不同的表。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="18-全文本搜索"><a class="header" href="#18-全文本搜索">18 全文本搜索</a></h1>
<h2 id="181-理解全文本搜索"><a class="header" href="#181-理解全文本搜索">18.1 理解全文本搜索</a></h2>
<p>并非所有引擎都支持全文本搜索，MySQL支持几种基本的数据库引擎。并非所有的引擎都支持全文本搜索。两个最常使用的引擎为MyISAM和InnoDB，前者支持全文本搜索，而后者不支持。</p>
<p>LIKE通过统配操作匹配文本，通过LIKE能查找包含特殊值或部分值的行。</p>
<p>虽然这些搜索机制很有用，但存在几个重要的限制</p>
<ul>
<li>性能——通配符和正则表达式匹配通常要求MySQL尝试匹配表中所有行(而且这些搜索极少使用表索引)。因此，由于被搜索行数不断增加，这些搜索可能非常耗时。</li>
<li>明确控制——使用通配符和正则表达式匹配，很难(而且并不总是能)明确地控制匹配什么和不匹配什么。</li>
<li>智能化结果——虽然基于通配符和正则表达式的搜索提供了非常灵活的搜索，但他们都不能提供一种智能化的选择结果的方法。</li>
</ul>
<p>所有这些限制以及更多的限制都可以使用全文本搜索来解决。在使用全文本搜索的时候，MySQL不需要分别查看每个行，不需要分别分析和处理每个词。MySQL创建指定列中各词的一个索引，搜索可以针对这些词进行。这样，MySQL可以快速有效地决定哪些词匹配(哪些行包含它们)，哪些词不匹配，它的匹配频率等。</p>
<h2 id="182-使用全文本搜索"><a class="header" href="#182-使用全文本搜索">18.2 使用全文本搜索</a></h2>
<p>为了使用全文本搜索，必须索引被搜索的列，而且要随着数据的改变不断底重新索引。在对表列进行适当的设计后，MySQL会自动进行所有列的索引和重新索引。</p>
<p>在索引后，SELECT可以Match()和Against()一起使用来实际执行搜索。</p>
<h3 id="1821-启用全文本搜索支持"><a class="header" href="#1821-启用全文本搜索支持">18.2.1 启用全文本搜索支持</a></h3>
<p>一般在创建表的时候启用全文本搜索。CREATE TABLE语句接受FULLTEXT子句，它给出被索引列的一个都好分隔的列表。</p>
<pre><code class="language-SQL">CREATE TABLE productnotes
(
  note_id    int           NOT NULL AUTO_INCREMENT,
  prod_id    char(10)      NOT NULL,
  note_date datetime       NOT NULL,
  note_text  text          NULL ,
  PRIMARY KEY(note_id),
  FULLTEXT(note_text)
) ENGINE=MyISAM;
</code></pre>
<p>在定义之后，MySQL自动维护该索引。在增加、更新或删除行的时候索引随之更新。</p>
<p>可以在创建表时指定FULLTEXT，或者在稍后指定(在这种情况下所有已有的数据必须立刻索引)。</p>
<p><strong>不要在导入数据时使用FULLTEXT</strong> 更新索引要花时间，虽然不是很多，但毕竟要花时间。如果正在导入数据到一个新表，此时不应该启用FULLTEXT索引。应该首先导入所有数据，然后再修改表，定义FULLTEXT。这样有助于更快地导入数据(而且使索引数据的总时间小于在导入每行时分别进行索引所需的总时间)。</p>
<h3 id="1822-进行全文本搜索"><a class="header" href="#1822-进行全文本搜索">18.2.2 进行全文本搜索</a></h3>
<p>在索引之后，使用两个函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT note_text FROM productnotes WHERE Match(note_text) Against('rabbit');
+----------------------------------------------------------------------------------------------------------------------+
| note_text                                                                                                            |
+----------------------------------------------------------------------------------------------------------------------+
| Customer complaint: rabbit has been able to detect trap, food apparently less effective now.                         |
| Quantity varies, sold by the sack load.
All guaranteed to be bright and orange, and suitable for use as rabbit bait. |
+----------------------------------------------------------------------------------------------------------------------+
2 rows in set (0.000 sec)
</code></pre>
<p><strong>使用完整的Match()说明</strong> 传递给Match()的值必须与FULLTEXT()定义中的相同。如果指定多个列，则必须列出它们(而且次序正确)。</p>
<p><strong>搜索不区分大小写</strong> 除非使用BINARY方式(本章中没有介绍)，否则全文本搜索不区分大小写。</p>
<p>全文本搜索的一个重要部分就是对结果排序。具有较高等级的行先返回(因为这些行很可能是你真正想要的行)。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT note_text,Match(note_text) Against('rabbit') AS rank FROM productnotes;
+-----------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+
| note_text                                                                                                                                                 | rank               |
+-----------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+
| Customer complaint:
Sticks not individually wrapped, too easy to mistakenly detonate all at once.
Recommend individual wrapping.                          |                  0 |
| Can shipped full, refills not available.
Need to order new can if refill needed.                                                                          |                  0 |
| Safe is combination locked, combination not provided with safe.
This is rarely a problem as safes are typically blown up or dropped by customers.         |                  0 |
| Quantity varies, sold by the sack load.
All guaranteed to be bright and orange, and suitable for use as rabbit bait.                                      | 1.5905543565750122 |
| Included fuses are short and have been known to detonate too quickly for some customers.
Longer fuses are available (item FU1) and should be recommended. |                  0 |
| Matches not included, recommend purchase of matches or detonator (item DTNTR).                                                                            |                  0 |
| Please note that no returns will be accepted if safe opened using explosives.                                                                             |                  0 |
| Multiple customer returns, anvils failing to drop fast enough or falling backwards on purchaser. Recommend that customer considers using heavier anvils.  |                  0 |
| Item is extremely heavy. Designed for dropping, not recommended for use with slings, ropes, pulleys, or tightropes.                                       |                  0 |
| Customer complaint: rabbit has been able to detect trap, food apparently less effective now.                                                              | 1.6408053636550903 |
| Shipped unassembled, requires common tools (including oversized hammer).                                                                                  |                  0 |
| Customer complaint:
Circular hole in safe floor can apparently be easily cut with handsaw.                                                                |                  0 |
| Customer complaint:
Not heavy enough to generate flying stars around head of victim. If being purchased for dropping, recommend ANV02 or ANV03 instead.   |                  0 |
| Call from individual trapped in safe plummeting to the ground, suggests an escape hatch be added.
Comment forwarded to vendor.                            |                  0 |
+-----------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+
14 rows in set (0.000 sec)
</code></pre>
<p>在SELECT而不是WHERE子句中使用Match()和Against()。Match()和Against()用来建立一个计算列，此列包含全文本搜索计算出的等级值。等级由MySQL根据行中词的数目、唯一词的数目、整个索引中词的总数以及包含该词的行的数目计算出来。</p>
<p><strong>排序多个搜索项</strong> 如果指定多个搜索项，则包含多数匹配词的那些行将具有比包含较少词(或仅有一个匹配)的那些行高的等级值。</p>
<p>全文本搜索提供了简单LIKE搜索不能提供的功能。而且，由于数据是索引的，全文本搜索还相当快。</p>
<h3 id="1823-使用查询扩展"><a class="header" href="#1823-使用查询扩展">18.2.3 使用查询扩展</a></h3>
<p>查询扩展用来设法放宽所返回的全文本搜索结果的范围。在使用查询扩展时，MySQL对数据和索引进行两遍扫描来完成搜索</p>
<ul>
<li>首先，进行一个基本的全文本搜索，找出与搜索条件匹配的所有行；</li>
<li>其次，MySQL检查这些匹配行并选择所有有用的词。</li>
<li>再其次，MySQL再次进行全文本搜索，这次不仅使用原来的条件，而且还使用所有有用的词。</li>
</ul>
<p><strong>只用于MySQL版本4.1.1或更高级的版本</strong> 查询扩展功能是在MySQL4.1.1中引入的，因此不能用于之前的版本。</p>
<p>比如，没有查询扩展：</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT note_text FROM productnotes WHERE Match(note_text) Against('anvils');
+----------------------------------------------------------------------------------------------------------------------------------------------------------+
| note_text                                                                                                                                                |
+----------------------------------------------------------------------------------------------------------------------------------------------------------+
| Multiple customer returns, anvils failing to drop fast enough or falling backwards on purchaser. Recommend that customer considers using heavier anvils. |
+----------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.000 sec)
</code></pre>
<p>只有一行包含词anvils，因此只返回一行。下面是相同的搜索，这次使用查询扩展：</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT note_text FROM productnotes WHERE Match(note_text) Against('anvils' WITH QUERY EXPANSION);
+----------------------------------------------------------------------------------------------------------------------------------------------------------+
| note_text                                                                                                                                                |
+----------------------------------------------------------------------------------------------------------------------------------------------------------+
| Multiple customer returns, anvils failing to drop fast enough or falling backwards on purchaser. Recommend that customer considers using heavier anvils. |
| Customer complaint:
Sticks not individually wrapped, too easy to mistakenly detonate all at once.
Recommend individual wrapping.                         |
| Customer complaint:
Not heavy enough to generate flying stars around head of victim. If being purchased for dropping, recommend ANV02 or ANV03 instead.  |
| Please note that no returns will be accepted if safe opened using explosives.                                                                            |
| Customer complaint: rabbit has been able to detect trap, food apparently less effective now.                                                             |
| Customer complaint:
Circular hole in safe floor can apparently be easily cut with handsaw.                                                               |
| Matches not included, recommend purchase of matches or detonator (item DTNTR).                                                                           |
+----------------------------------------------------------------------------------------------------------------------------------------------------------+
7 rows in set (0.000 sec)
</code></pre>
<p>这次返回了7行。第一行词包括anvils，因此等级最高。第二行与anvils无关，但它因为包含第一行中的两个词(customer和recommend)，所以也被检索出来。第三行也包含这两个相同的词，但它们在文本中的位置更靠后且分开的更远，因此也包含这一行，但等级为第三。</p>
<p>正如所见，查询扩展极大地增加了返回的行数，但这样做也增加了你实际上并不想要的行的数目。</p>
<p><strong>行越多越好</strong> 表中的行越多(这些行中的文本就越多)，使用查询扩展返回的结果越好。</p>
<h3 id="1824-布尔文本搜索"><a class="header" href="#1824-布尔文本搜索">18.2.4 布尔文本搜索</a></h3>
<p>MySQL支持全文本搜索的另外一种形式，称为布尔方式(boolean mode)。该方式可以提供如下内容的细节：</p>
<ul>
<li>要匹配的词；</li>
<li>要排斥的词(如果某行包含要排斥的词，即使它包含要匹配的词也不返回)；</li>
<li>排列提示(指定某些词比其他词更重要，更重要的词等级更高)；</li>
<li>表达式分组；</li>
</ul>
<p><strong>即使没有FULLTEXT索引也可以使用</strong> 布尔方式不同于迄今为止所使用的全文本搜索语法的地方在于，即使没有定义FULLTEXT索引也可以使用它。但这是一种非常缓慢的操作(其性能将随着数据量的增加而降低)。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT note_text FROM productnotes WHERE Match(note_text) Against('heavy' IN BOOLEAN MODE);
+---------------------------------------------------------------------------------------------------------------------------------------------------------+
| note_text
                                  |
+---------------------------------------------------------------------------------------------------------------------------------------------------------+
| Item is extremely heavy. Designed for dropping, not recommended for use with slings, ropes, pulleys, or tightropes.                                     |
| Customer complaint:
Not heavy enough to generate flying stars around head of victim. If being purchased for dropping, recommend ANV02 or ANV03 instead. |
+---------------------------------------------------------------------------------------------------------------------------------------------------------+
2 rows in set (0.000 sec)
</code></pre>
<p>此全文本搜索检索包含词heavy的所有行(有两行)。其中使用了关键字IN BOOLEAN MODE，但实际上没有指定布尔操作符，因此，其结果与没有指定布尔方式的结果相同。</p>
<p>为了匹配包含heavy但不包含任意以rope开始的词的行，可使用以下的查询。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT note_text FROM productnotes WHERE Match(note_text) Against('heavy -rope*' IN BOOLEAN MODE);
+---------------------------------------------------------------------------------------------------------------------------------------------------------+
| note_text
                   |
+---------------------------------------------------------------------------------------------------------------------------------------------------------+
| Customer complaint:
Not heavy enough to generate flying stars around head of victim. If being purchased for dropping, recommend ANV02 or ANV03 instead. |
+---------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.000 sec)
</code></pre>
<p>这次只返回一行，仍然匹配词heavy，但-rope*明确地只是MySQL配出包含rope*的行。</p>
<p>在MySQL 4.x中所需的代码更改 如果使用的是MySQL 4.x，则上面的例子可能不返回任何行。这是*操作符处理中的一个错误。要在MySQL 4.x中使用这个例子，使用-ropes而不是-rope*(排除ropes而不是排除任何以rope开始的词)。</p>
<p>全文本布尔操作符</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">布尔操作符</th><th style="text-align: center">说明</th></tr></thead><tbody>
<tr><td style="text-align: center">+</td><td style="text-align: center">包含，此必须存在</td></tr>
<tr><td style="text-align: center">-</td><td style="text-align: center">排除，词必须不存在</td></tr>
<tr><td style="text-align: center">&gt;</td><td style="text-align: center">包含，而且增加等级值</td></tr>
<tr><td style="text-align: center">&lt;</td><td style="text-align: center">包含，且减少等级值</td></tr>
<tr><td style="text-align: center">()</td><td style="text-align: center">把词组成子表达式(允许这些子表达式作为一个组被包含、排除、排列等)</td></tr>
<tr><td style="text-align: center">~</td><td style="text-align: center">取消一个词的排序值</td></tr>
<tr><td style="text-align: center">*</td><td style="text-align: center">词尾的通配符</td></tr>
<tr><td style="text-align: center">&quot;&quot;</td><td style="text-align: center">定义一个短语(与单个词的列表不一样，它匹配整个短语以便包含或排除这个短语)</td></tr>
</tbody></table>
</div>
<p>举例说明：</p>
<ul>
<li>匹配包含词rabbit和bait的行。</li>
</ul>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT note_text FROM productnotes WHERE Match(note_text) Against('+rabbit +bait' IN BOOLEAN MODE);
+----------------------------------------------------------------------------------------------------------------------+
| note_text                                                                                                            |
+----------------------------------------------------------------------------------------------------------------------+
| Quantity varies, sold by the sack load.
All guaranteed to be bright and orange, and suitable for use as rabbit bait. |
+----------------------------------------------------------------------------------------------------------------------+
1 row in set (0.000 sec)
</code></pre>
<ul>
<li>没有指定操作符，匹配包含rabbit和bait中的至少一个词的行。</li>
</ul>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT note_text FROM productnotes WHERE Match(note_text) Against('rabbit bait' IN BOOLEAN MODE);
+----------------------------------------------------------------------------------------------------------------------+
| note_text                                                                                                            |
+----------------------------------------------------------------------------------------------------------------------+
| Quantity varies, sold by the sack load.
All guaranteed to be bright and orange, and suitable for use as rabbit bait. |
| Customer complaint: rabbit has been able to detect trap, food apparently less effective now.                         |
+----------------------------------------------------------------------------------------------------------------------+
2 rows in set (0.000 sec)
</code></pre>
<ul>
<li>匹配短语rabbit bait而不是匹配两个词rabbit和bait。</li>
</ul>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT note_text FROM productnotes WHERE Match(note_text) Against('&quot;bait rabbit&quot;' IN BOOLEAN MODE);
Empty set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT note_text FROM productnotes WHERE Match(note_text) Against('&quot;rabbit bait&quot;' IN BOOLEAN MODE);
+----------------------------------------------------------------------------------------------------------------------+
| note_text                                                                                                            |
+----------------------------------------------------------------------------------------------------------------------+
| Quantity varies, sold by the sack load.
All guaranteed to be bright and orange, and suitable for use as rabbit bait. |
+----------------------------------------------------------------------------------------------------------------------+
1 row in set (0.000 sec)
</code></pre>
<ul>
<li>匹配rabbit和carrot，增加前者的等级，降低后者的等级。</li>
</ul>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT note_text FROM productnotes WHERE Match(note_text) Against('&gt;rabbit &lt;bait' IN BOOLEAN MODE);
+----------------------------------------------------------------------------------------------------------------------+
| note_text                                                                                                            |
+----------------------------------------------------------------------------------------------------------------------+
| Quantity varies, sold by the sack load.
All guaranteed to be bright and orange, and suitable for use as rabbit bait. |
| Customer complaint: rabbit has been able to detect trap, food apparently less effective now.                         |
+----------------------------------------------------------------------------------------------------------------------+
2 rows in set (0.000 sec)
</code></pre>
<ul>
<li>匹配safe和combination，降低后者的等级。</li>
</ul>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT note_text FROM productnotes WHERE Match(note_text) Against('+safe +(&lt;combination)' IN BOOLEAN MODE);
+---------------------------------------------------------------------------------------------------------------------------------------------------+
| note_text                                                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------------------------------------+
| Safe is combination locked, combination not provided with safe.
This is rarely a problem as safes are typically blown up or dropped by customers. |
+---------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.000 sec)
</code></pre>
<p><strong>排列而不排序</strong> 在布尔方式中，不按等级值降序排序返回的行。</p>
<h3 id="1825-全文本搜索的使用说明"><a class="header" href="#1825-全文本搜索的使用说明">18.2.5 全文本搜索的使用说明</a></h3>
<p><em><strong>重要说明</strong></em>：</p>
<ul>
<li>在索引全文本数据时，短词被忽略且从索引中排除。短词定义为那些具有3个或3个以下字符的词（如果需要，这个数目可以更改）。</li>
<li>MySQL带有一个内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略。如果需要，可以覆盖这个列表（请参阅MySQL文档以了解如何完成此工作）。</li>
<li>许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。因此，MySQL规定了一条50%规则，如果一个词出现在50%以上的行中，则将它作为一个非用词忽略。50%规则不适用于IN BOOLEAN MODE。</li>
<li>如果表中的行数少于3行，则全文本搜索不返回结果（因为每个词或者不出现，或者至少出现在50%的行中）。</li>
<li>忽略词中的单引号。例如，don't索引为dont。</li>
<li>不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果。 </li>
<li>仅在MyISAM数据库引擎中支持全文本搜索。</li>
</ul>
<h3 id="1826-邻近操作符"><a class="header" href="#1826-邻近操作符">18.2.6 邻近操作符</a></h3>
<p>邻近搜索是许多全文本搜索支持的一个特性，它能搜索相邻的词（在相同的句子中、相同的段落中或者在特定数目的词的部分中，等等）。</p>
<p>笔记摘录的书写成的时候MySQL还不支持邻近操作符，待补充。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="19-插入数据"><a class="header" href="#19-插入数据">19 插入数据</a></h1>
<h2 id="191-数据插入"><a class="header" href="#191-数据插入">19.1 数据插入</a></h2>
<p>INSERT用来插入(或添加)行到数据库表的。插入可以用几种方式使用：</p>
<ul>
<li>插入完整的行；</li>
<li>插入行的一部分；</li>
<li>插入多行；</li>
<li>插入某些查询的结果。</li>
</ul>
<p><strong>插入及系统安全</strong> 可针对每个表或每个用户，利用MySQl的安全机制禁止使用INSERT语句。</p>
<h2 id="192-插入完整的行"><a class="header" href="#192-插入完整的行">19.2 插入完整的行</a></h2>
<p>指定表名和被插入到新行中的值</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; INSERT INTO Customers VALUES(NULL, 'Pep E. LaPew', '100 Main Street', 'Los Angeles', 'CA', '90046', 'USA', NULL, NULL);
</code></pre>
<p><strong>没有输出</strong> INSERT语句一半不会产生输出。</p>
<p>如果某列没有值，应该使用NULL值(如果允许的话)。各个列必须以它们在表定义中出现的次序填充。</p>
<p>虽然这种语法很简单，但并不安全，应该尽量避免使用。上面的SQL语句高度依赖于表中列的定义次序，并且还依赖于其次序容易获得的信息。即使可得到这种次序信息，也不能保证下一次表结构变动后各个列保持完全相同的次序。</p>
<p>这是更安全的一种做法：</p>
<pre><code class="language-SQL">INSERT INTO customers(cust_id, cust_name) VALUES(10001, 'Coyote Inc.');
</code></pre>
<p>在表名后的括号里明确地给出了列名。在插入行时，MySQL将用VALUES列表中的相应值填入列表中的对应项。其优点是，即使表的结构改变，此INSERT语句仍然能正确工作。而且未指定的列不用填NULL。</p>
<p><strong>省略列</strong> 如果表的定义允许，则可以在INSERT操作中省略某些列。省略的列必须满足以下某个条件。</p>
<ul>
<li>该列定义为允许NULL值（无值或空值）。</li>
<li>在表定义中给出默认值。这表示如果不给出值，将使用默认值。 </li>
</ul>
<p>如果对表中不允许NULL值且没有默认值的列不给出值，则MySQL将产生一条错误消息，并且相应的行插入不成功。</p>
<p><strong>提高整体性能</strong> 数据库经常被多个客户访问，对处理什么请求以及用什么次序处理进行管理是MySQL的任务。INSERT操作可能很耗时（特别是有很多索引需要更新时），而且它可能降低等待处理的SELECT语句的性能。</p>
<p>如果数据检索是最重要的（通常是这样），则你可以通过在INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL降低INSERT语句的优先级，如 <code>INSERT LOW_PRIORITY INTO</code> 。这同样适用于 <code>UPDATE</code> 和 <code>DELETE</code> 语句。</p>
<h2 id="193-插入多个行"><a class="header" href="#193-插入多个行">19.3 插入多个行</a></h2>
<p>可以多次INSERT来插入多条数据。但更建议组合INSERT(性能更好)。</p>
<pre><code class="language-SQL">INSERT INTO customers(cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country) VALUES('Pep E. LaPew','100 Main Street','Los Angeles','CA','90046','USA'),('M. Martian','42 Galaxy Way','New York','NY','11213','USA');
Query OK, 2 rows affected (0.005 sec)
Records: 2  Duplicates: 0  Warnings: 0
</code></pre>
<p>其中单条INSERT语句有多组值，每组值用一对圆括号括起来，用逗号分隔。</p>
<h2 id="194-插入检索出的数据"><a class="header" href="#194-插入检索出的数据">19.4 插入检索出的数据</a></h2>
<p>INSERT一般用来给表插入一个指定列值的行。但是，INSERT还存在另一种形式，可以利用它将一条SELECT语句的结果插入表中。这就是所谓的INSERT SELECT，顾名思义，它是由一条INSERT语句和一条SELECT语句组成的。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; INSERT INTO customers(cust_id,cust_contact) SELECT cust_id,cust_contact FROM custnew;
</code></pre>
<p>这个例子使用INSERT SELECT从custnew中将所有数据导入customers。SELECT语句从custnew检索出要插入的值，而不是列出它们。</p>
<p><strong>INSERT SELECT中的列名</strong> 为简单起见，这个例子在INSERT和SELECT语句中使用了相同的列名。但是，不一定要求列名匹配。事实上，MySQL甚至不关心SELECT返回的列名。它使用的是列的位置，因此SELECT中的第一列（不管其列名）将用来填充表列中指定的第一个列，第二列将用来填充表列中指定的第二个列，如此等等。这对于从使用不同列名的表中导入数据是非常有用的。</p>
<p>INSERT SELECT中SELECT语句可包含WHERE子句以过滤插入的数据。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="20-更新和删除数据"><a class="header" href="#20-更新和删除数据">20 更新和删除数据</a></h1>
<h2 id="201-更新数据"><a class="header" href="#201-更新数据">20.1 更新数据</a></h2>
<p>使用UPDATE更新数据表中的数据有两种方式：</p>
<ul>
<li>更新表中特定行</li>
<li>更新表中所有行</li>
</ul>
<p><strong>不要省略</strong><code>WHERE</code><strong>子句</strong> 不带WHERE会更新表中所有的行。</p>
<p>基本的UPDATE语句由3部分组成：</p>
<ul>
<li>要更新的表；</li>
<li>列名和它们的新值；</li>
<li>确定要更新行的过滤条件。</li>
</ul>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; UPDATE customers SET cust_name='The Fudds', cust_email='elmer@fudd.com' WHERE cust_id=10005;
</code></pre>
<p>在更新多个列时，只需要使用单个SET命令，每个“列=值”对之间用逗号分隔。</p>
<p><strong>在UPDATE语句中使用子查询</strong> UPDATE语句中可以使用子查询，使得能用SELECT语句检索出的数据更新列数据。</p>
<p><strong>IGNORE关键字</strong> 如果用UPDATE语句更新多行，并且在更新这些行中的一行或多行时出现一个错误，则整个UPDATE操作被取消(没有任何修改被执行)。如果要让错误发生后操作继续执行，可使用IGNORE关键字，如 <code>UPDATE IGNORE customers ...</code>。</p>
<h2 id="202-删除数据"><a class="header" href="#202-删除数据">20.2 删除数据</a></h2>
<p>使用DELETE语句从表中删除数据有两种方式：</p>
<ul>
<li>从表中删除特定的行</li>
<li>从表中删除所有行</li>
</ul>
<p><strong>不要省略</strong><code>WHERE</code><strong>子句</strong> 不带WHERE会删除表中所有的行。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; DELETE FROM customers WHERE cust_id=10006;
</code></pre>
<p>DELETE删除的是数据行(不能用来删除表)，因此不需要列名或者通配符。</p>
<p><strong>更快的删除</strong> 如果想从表中删除所有行，不要使用DELETE。可以使用 <code>TRUNCATE TABLE</code> 语句，他完成相同的工作，但速度更快(TRUNCATE TABLE实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据)。</p>
<h2 id="203-更新和删除的指导原则"><a class="header" href="#203-更新和删除的指导原则">20.3 更新和删除的指导原则</a></h2>
<p>下面是一些DELETE和UPDATE时建议养成的好习惯：</p>
<ul>
<li>除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE子句的UPDATE或DELETE语句。</li>
<li>保证每个表都有主键（如果忘记这个内容，请参阅第15章），尽可能像WHERE子句那样使用它（可以指定各主键、多个值或值的范围）。</li>
<li>在对UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确。</li>
<li>本人尚未理解：使用强制实施引用完整性的数据库（关于这个内容，请参阅第15章），这样MySQL将不允许删除具有与其他表相关联的数据的行。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="21-创建和操纵表"><a class="header" href="#21-创建和操纵表">21 创建和操纵表</a></h1>
<h2 id="211-create-table创建表"><a class="header" href="#211-create-table创建表">21.1 CREATE TABLE创建表</a></h2>
<h3 id="2111-表创建基础"><a class="header" href="#2111-表创建基础">21.1.1 表创建基础</a></h3>
<p>CREATE TABLE需要下列信息：</p>
<ul>
<li>新表的名字，在关键字CREATE TABLE之后给出；</li>
<li>表列的名字和定义，用逗号分隔。</li>
</ul>
<p>CREATE TABLE语句也可能会包括其他关键字或选项，但至少要包括表的名字和列的细节。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; CREATE TABLE customers(
  cust_id      int       NOT NULL AUTO_INCREMENT,
  cust_name    char(50)  NOT NULL ,
  cust_address char(50)  NULL ,
  cust_city    char(50)  NULL ,
  cust_state   char(5)   NULL ,
  cust_zip     char(10)  NULL ,
  cust_country char(50)  NULL ,
  cust_contact char(50)  NULL ,
  cust_email   char(255) NULL ,
  PRIMARY KEY (cust_id)
) ENGINE=InnoDB;
</code></pre>
<p>每列的定义以列名(在表中必须唯一)开始，后跟列的数据类型(<a href="./appendixD.html">附录D</a>列出了MySQL支持的数据类型)。表的主键可以在创建表时用PRIMARY KEY关键字指定。</p>
<p><strong>处理现有的表</strong> 在创建新表时，指定的表名必须不存在，否则将出错。如果要防止意外覆盖已有的表，SQL要求首先手工删除该表（请参阅后面的小节），然后再重建它，而不是简单地用创建表语句覆盖它。如果你仅想在一个表不存在时创建它，应该在表名后给出 <code>IF NOT EXISTS</code>。这样做不检查已有表的模式是否与你打算创建的表模式相匹配。它只是查看表名是否存在，并且仅在表名不存在时创建它。</p>
<h3 id="2112-使用null值"><a class="header" href="#2112-使用null值">21.1.2 使用NULL值</a></h3>
<p>创建时指定NOT NULL的列不接受没有值的行</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; CREATE TABLE orders(
  order_num  int      NOT NULL AUTO_INCREMENT,
  order_date datetime NOT NULL ,
  cust_id    int      NOT NULL ,
  PRIMARY KEY (order_num)
) ENGINE=InnoDB;
</code></pre>
<p><strong>理解NULL</strong> 不要把NULL值与空串相混淆。NULL值是没有值，它不是空串。如果指定''（两个单引号，其间没有字符），这在NOT NULL列中是允许的。空串是一个有效的值，它不是无值。NULL值用关键字NULL而不是空串指定。</p>
<h3 id="2113-关于主键"><a class="header" href="#2113-关于主键">21.1.3 关于主键</a></h3>
<p><strong>主键值必须唯一</strong>。即，表中的每个行必须具有唯一的主键值。如果主键使用单个列，则它的值必须唯一。如果使用多个列，则这些列的组合值必须唯一。</p>
<p>单个列作为主键的定义如 <code>PRIMARY KEY (vend_id)</code>。</p>
<p>创建由多个列组成的主键，应该以逗号分隔的列表给出各列名，如：</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; CREATE TABLE orderitems(
  order_num  int          NOT NULL ,
  order_item int          NOT NULL ,
  prod_id    char(10)     NOT NULL ,
  quantity   int          NOT NULL ,
  item_price decimal(8,2) NOT NULL ,
  PRIMARY KEY (order_num, order_item)
) ENGINE=InnoDB;
</code></pre>
<p>主键也可以在表创建后定义，主键只能使用不允许为NULL值的列。</p>
<h3 id="2114-使用auto_increment"><a class="header" href="#2114-使用auto_increment">21.1.4 使用AUTO_INCREMENT</a></h3>
<p>AUTO_INCREMENT告诉MySQL，本列每当增加一行时自动增量。每次执行一个INSERT操作时，MySQL自动对该列增量（从而才有这个关键字AUTO_INCREMENT），给该列赋予下一个可用的值。</p>
<p><strong>确定AUTO_INCREMENT值</strong> <code>SELECT last_insert_id()</code> 返回最后一个AUTO_INCREMENT值。</p>
<h3 id="2115-指定默认值"><a class="header" href="#2115-指定默认值">21.1.5 指定默认值</a></h3>
<p>用DEFAULT关键字指定默认值：</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; CREATE TABLE orderitems(
  order_num  int          NOT NULL ,
  order_item int          NOT NULL ,
  prod_id    char(10)     NOT NULL ,
  quantity   int          NOT NULL DEFAULT 1,
  item_price decimal(8,2) NOT NULL ,
  PRIMARY KEY (order_num, order_item)
) ENGINE=InnoDB;
</code></pre>
<p><strong>不允许函数</strong> 与大多数DBMS不一样，MySQL不允许使用函数作为默认值，它只支持常量。</p>
<p><strong>使用默认值而不是NULL值</strong> 许多数据库开发人员使用默认值而不是NULL列，特别是对用于计算或数据分组的列更是如此。 </p>
<h3 id="2116-引擎类型"><a class="header" href="#2116-引擎类型">21.1.6 引擎类型</a></h3>
<p>与其他DBMS一样，MySQL有一个具体管理和处理数据的内部引擎。</p>
<p>MySQL具有多种引擎。它打包多个引擎，这些引擎都隐藏在MySQL服务器内，全都能执行CREATE TABLE和SELECT等命令。</p>
<p>为什么要发行多种引擎呢？因为它们具有各自不同的功能和特性，为不同的任务选择正确的引擎能获得良好的功能和灵活性。</p>
<p>如果省略ENGINE=语句，则使用默认引擎（很可能是MyISAM），多数SQL语句都会默认使用它。但并不是所有语句都默认使用它，这就是为什么ENGINE=语句很重要。引擎类型可以混用。</p>
<p>几个重要的引擎：</p>
<ul>
<li>InnoDB是一个可靠的事务处理引擎(<a href="./chapter_26.html">详见26章</a>)，不支持全文本搜索；</li>
<li>MEMORY在功能上等同于MyISAM，但由于数据存储在内存(不是磁盘)中，速度很快(适用于临时表)。</li>
<li>MyISAM是一个性能极高的引擎，支持全文本搜索，但不支持事务处理。</li>
</ul>
<h2 id="212-更新表"><a class="header" href="#212-更新表">21.2 更新表</a></h2>
<p>可以使用ALTER TABLE语句更新表，但理想状态下，当表中存储数据以后，该表就不应该再被更新。<strong>在表的设计过程中需要花费大量时间来考虑，以便后期不对该表进行大的改动。</strong></p>
<p>ALTER TABLE更改表结构需要下面的信息：</p>
<ul>
<li>在ALTER TABLE之后给出要更改的表明(该表必须存在，否则将出错)；</li>
<li>更改列表；</li>
</ul>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; ALTER TABLE vendors ADD vend_phone CHAR(20);
</code></pre>
<p>该语句给vendors表增加一个名为vend_phone的列，必须明确其数据类型。</p>
<p>ALTER TABLE的一种常见用途是定义外键：</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; ALTER TABLE orderitems ADD CONSTRAINT fk_orderitems_orders FOREIGN KEY (order_num) REFERENCES orders (order_num);

MariaDB [testdatabase]&gt; ALTER TABLE orderitems ADD CONSTRAINT fk_orderitems_products FOREIGN KEY (prod_id) REFERENCES products (prod_id);

MariaDB [testdatabase]&gt; ALTER TABLE orders ADD CONSTRAINT fk_orders_customers FOREIGN KEY (cust_id) REFERENCES customers (cust_id);

MariaDB [testdatabase]&gt; ALTER TABLE products ADD CONSTRAINT fk_products_vendors FOREIGN KEY (vend_id) REFERENCES vendors (vend_id);
</code></pre>
<p>复杂的表结构更改一半需要手动删除，设计以下步骤：</p>
<ul>
<li>用新的列布局创建一个新表；</li>
<li>使用INSERT SELECT语句从旧表复制数据到新表。如果有必要，可使用转换函数和计算字段；</li>
<li>检验包含所需数据的新表；</li>
<li>重命名旧表(如果确定，可以删除它)；</li>
<li>用旧表原来的名字重命名新表；</li>
<li>根据需要，重新创建触发器、存储过程、索引和外键。</li>
</ul>
<p><strong>小心使用ALTER TABLE</strong> 使用ALTER TABLE要极为小心，应该在进行改动前做一个完整的备份（模式和数据的备份）。数据库表的更改不能撤销，如果增加了不需要的列，可能不能删除它们。类似地，如果删除了不应该删除的列，可能会丢失该列中的所有数据。</p>
<h2 id="213-删除表"><a class="header" href="#213-删除表">21.3 删除表</a></h2>
<p>删除表(删除整个表而不是删除表中的内容)非常简单，使用DROP TABLE语句即可：<code>DROP TABLE customers2;</code>。</p>
<h2 id="214-重命名表"><a class="header" href="#214-重命名表">21.4 重命名表</a></h2>
<p>RENAME TABLE语句可以重命名一个表：<code>RENAME TABLE customers2 TO customers;</code>。</p>
<p>RENAME TABLE所作的仅是重命名一个表。可以使用下面的语句对多个表重命名：</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; RENAME TABLE backup_customers TO customers, backup_vendors TO vendors, backup_products TO products;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="22-使用视图"><a class="header" href="#22-使用视图">22 使用视图</a></h1>
<h2 id="221-视图"><a class="header" href="#221-视图">22.1 视图</a></h2>
<p>视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。</p>
<h3 id="2211-为什么使用视图"><a class="header" href="#2211-为什么使用视图">22.1.1 为什么使用视图</a></h3>
<p>常见应用：</p>
<ul>
<li>重用SQL语句。</li>
<li>简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节。</li>
<li>使用表的组成部分而不是整个表。</li>
<li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。</li>
<li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li>
</ul>
<p>在视图创建之后可以用与表基本相同的方式利用它们。视图仅仅是用来查看存储在别处的数据的一种设施。视图本身不包含数据，因此它们返回的数据是从其他表中检索出来的。再添加或更改这些表中的数据时，视图将返回改变过的数据。</p>
<p><strong>性能问题</strong> 因为视图不包含数据，所以每次使用视图的时候，都必须处理查询执行时所需的任一个检索。如果用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害。因此，在部署使用了大量视图的应用前，应该进行测试。</p>
<h3 id="2212-视图的规则和限制"><a class="header" href="#2212-视图的规则和限制">22.1.2 视图的规则和限制</a></h3>
<p>常见的规则和限制：</p>
<ul>
<li>与表名一样，视图必须唯一命名；</li>
<li>对于可以创建的视图数目没有限制；</li>
<li>视图可以嵌套，即可以用一个视图来创建另外一个视图；</li>
<li>ORDER BY可以用在视图中，但是如果创建视图的检索(源)中也使用了ORDER BY，视图(源)中的ORDER BY将被覆盖。</li>
<li>视图不能索引，也不能有关联的触发器或默认值</li>
<li>视图可以和表一起使用。</li>
</ul>
<h2 id="222-使用视图"><a class="header" href="#222-使用视图">22.2 使用视图</a></h2>
<p>视图的创建：</p>
<ul>
<li>用CREATE VIEW语句来创建视图；</li>
<li>使用 <code>SHOW CREATE VIEW viewname;</code> 来查看创建视图的语句；</li>
<li>使用DROP删除视图，其语法为 <code>DROP VIEW viewname;</code>。</li>
<li>更新视图时，可以先用DROP再用CREATE，也可以直接使用 <code>CREATE OR REPLACE VIEW</code>。如果要更新的视图不存在，则 <code>CREATE OR REPLACE VIEW</code> 会创建一个视图，否则替换原视图。</li>
</ul>
<h3 id="2221-利用视图简化复杂的联结"><a class="header" href="#2221-利用视图简化复杂的联结">22.2.1 利用视图简化复杂的联结</a></h3>
<p>视图最常见的应用之一是隐藏复杂的SQL：</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; CREATE VIEW productcustomers AS SELECT cust_name,cust_contact,prod_id FROM customers,orders,orderitems WHERE customers.cust_id=orders.cust_id AND orderitems.order_num=orders.order_num;
Query OK, 0 rows affected (0.007 sec)

MariaDB [testdatabase]&gt; SELECT cust_name,cust_contact FROM productcustomers WHERE prod_id='TNT2';
+----------------+--------------+
| cust_name      | cust_contact |
+----------------+--------------+
| Coyote Inc.    | Y Lee        |
| Yosemite Place | Y Sam        |
+----------------+--------------+
2 rows in set (0.001 sec)
</code></pre>
<p><strong>创建可重用的视图</strong> 创建不受特定数据限制的视图是一种好办法。扩展视图的范围不仅使得它能被重用，而且甚至更有用。这样做不需要创建和维护多个类似视图。</p>
<h3 id="2222-用视图重新格式化检索出来的数据"><a class="header" href="#2222-用视图重新格式化检索出来的数据">22.2.2 用视图重新格式化检索出来的数据</a></h3>
<p>视图的另一种常见用途是重新格式化检索出来的数据。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT Concat(Rtrim(vend_name), ' (', RTrim(vend_country), ')') AS vend_title FROM vendors ORDER BY vend_name;
+-------------------------+
| vend_title              |
+-------------------------+
| ACME (USA)              |
| Anvils R Us (USA)       |
| Furball Inc. (USA)      |
| Jet Set (England)       |
| Jouets Et Ours (France) |
| LT Supplies (USA)       |
+-------------------------+
6 rows in set (0.001 sec)

MariaDB [testdatabase]&gt; CREATE VIEW vendorlocations AS SELECT Concat(RTrim(vend_name), '(', RTrim(vend_country), ')') AS vend_title FROM vendors ORDER BY vend_name;
Query OK, 0 rows affected (0.006 sec)

MariaDB [testdatabase]&gt; SELECT * FROM vendorlocations;
+------------------------+
| vend_title             |
+------------------------+
| ACME(USA)              |
| Anvils R Us(USA)       |
| Furball Inc.(USA)      |
| Jet Set(England)       |
| Jouets Et Ours(France) |
| LT Supplies(USA)       |
+------------------------+
6 rows in set (0.001 sec)
</code></pre>
<h3 id="2223-用视图过滤不想要的数据"><a class="header" href="#2223-用视图过滤不想要的数据">22.2.3 用视图过滤不想要的数据</a></h3>
<p>可以用视图过滤掉那些不需要的或者无效的数据(比如说没有值，NULL)。</p>
<p><strong>WHERE子句与WHERE子句</strong> 如果从视图检索数据时使用了一条WHERE子句，则两组子句（一组在视图中，另一组是传递给视图的）将自动组合。 </p>
<h3 id="2224-使用视图与计算字段"><a class="header" href="#2224-使用视图与计算字段">22.2.4 使用视图与计算字段</a></h3>
<p>创建每个结果的计算视图然后通过WHERE对视图进行筛选。</p>
<p>例子太长了，意思就是有商品、价格、数目构成的表，由所有的价格*数目构建视图，使用的时候只需筛选商品，不用再写计算的表达式了。</p>
<h3 id="2225-更新视图"><a class="header" href="#2225-更新视图">22.2.5 更新视图</a></h3>
<p>通常视图是可更新的(即可以使用INSERT、UPDATE和DELETE)，而这会影响到作为数据源的表(视图本身没有数据)。也就是说对视图增加或删除行，实际上是对其基表增加或删除行。</p>
<p>如果MySQL不能<strong>正确地确定被更新的源数据</strong>，则不允许更新（包括插入和删除）。这实际上意味着，如果视图定义中有以下操作，则不能进行视图的更新：</p>
<ul>
<li>分组(使用GROUP BY和HAVING)；</li>
<li>联结；</li>
<li>子查询；</li>
<li>并；</li>
<li>聚集函数；</li>
<li>DISTINCT；</li>
<li>计算列</li>
</ul>
<p><strong>将视图用于检索</strong> 一般，应该将视图用于检索（SELECT语句）而不用于更新（INSERT、UPDATE和DELETE）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="23-使用存储过程"><a class="header" href="#23-使用存储过程">23 使用存储过程</a></h1>
<h2 id="231-存储过程"><a class="header" href="#231-存储过程">23.1 存储过程</a></h2>
<p>存储过程简单来说就是为以后的使用而保存的一条或多条MySQL语句的集合。可将其视为皮文件，虽然它们的作用不仅限于批处理。</p>
<h2 id="232-为什么要使用存储过程"><a class="header" href="#232-为什么要使用存储过程">23.2 为什么要使用存储过程</a></h2>
<p>封装处理，简化操作。</p>
<p>保证数据完整性，防止错误。因为存储过程在多次的使用中执行的是相同的代码。</p>
<p>简化管理。如果数据结构有变更，那么管理人员只需要变更存储过程，使用人员不需要知道有哪些变化。</p>
<p>提高性能，使用存储过程比使用单独的SQL语句更快。</p>
<p>存在一些只能用在单个请求中的MySQL元素和特性，存储过程可以使用它们来编写功能更强更灵活的代码。</p>
<p>总结一下就是<strong>简单、安全、高性能。</strong></p>
<h2 id="233-使用存储过程"><a class="header" href="#233-使用存储过程">23.3 使用存储过程</a></h2>
<p>存储过程的执行远比其定义更经常遇到，因此先从执行存储过程开始介绍。</p>
<h3 id="2331-执行存储过程"><a class="header" href="#2331-执行存储过程">23.3.1 执行存储过程</a></h3>
<p>MySQL称存储过程的执行为调用，因此MySQL执行过程的语句为CALL。CALL接受存储过程的名字以及需要传递给它的任意参数。</p>
<p>如<code>CALL productpricing(@pricelow, @pricehigh, @priceaverage);</code>，存储过程可以显示结果，也可以不显示。</p>
<h3 id="2332-创建存储过程"><a class="header" href="#2332-创建存储过程">23.3.2 创建存储过程</a></h3>
<p>这是一个返回产品平均价格的存储过程：</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; CREATE PROCEDURE productpricing()
BEGIN
    SELECT Avg(prod_price) AS priceaverage FROM products;
END;
</code></pre>
<p>此存储过程名为productpricing，用<code>CREATE PROCEDURE productpricing()</code>语句定义。如果存储过程接受参数，它们将在<code>()</code>中列举出来。此存储过程没有参数，但后跟的<code>()</code>仍然需要。<code>BEGIN</code>和<code>END</code>语句用来限定存储过程体，过程体本身仅是一个简单的SELECT语句。</p>
<p>在MySQL处理这段代码时，它创建一个新的存储过程productpricing。没有返回数据，因为这段代码并未调用存储过程，这里只是为以后使用而创建它。</p>
<p><strong>mysql命令行客户机的分隔符</strong> 默认的MySQL语句分隔符为<code>;</code>。mysql命令行实用程序也使用<code>;</code>作为语句分隔符。如果命令行实用程序要解释存储过程自身内的<code>;</code>字符，则它们最终不会成为存储过程的成分，这会使存储过程中的SQL出现句法错误。解决办法是临时更改命令行实用程序的语句分隔符，如下所示:</p>
<pre><code class="language-SQL">DELIMITER //

CREATE PROCEDURE productpricing()
BEGIN
    SELECT Avg(prod_price) AS priceaverage FROM products;
END //

DELIMITER;
</code></pre>
<p>其中，<code>DELIMITER //</code>告诉命令行实用程序使用<code>//</code>作为新的语句结束分隔符，可以看到标志存储过程结束的END定义为<code>END //</code>而不是<code>END;</code>。这样，存储过程体内的;仍然保持不动，并且正确地传递给数据库引擎。最后，为恢复为原来的语句分隔符，可使用<code>DELIMITER;</code>。</p>
<p>除<code>\</code>符号外，任何字符都可以用作语句分隔符。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; CALL productpricing();
+--------------+
| priceaverage |
+--------------+
|    16.133571 |
+--------------+
1 rows in set (0.001 sec)
</code></pre>
<p><code>CALL productpricing();</code>执行创建的存储过程并返回结果。因为存储过程实际上是一种函数，所以存储过程后需要有<code>()</code>符号(即使不传递参数也需要)。</p>
<h3 id="2333-删除存储过程"><a class="header" href="#2333-删除存储过程">23.3.3 删除存储过程</a></h3>
<p>存储过程在创建之后，被保存在服务器上以供使用，直至被删除。可使用<code>DROP PROCEDURE productpricing;</code>。这条语句删除刚创建的存储过程。这里并没有使用<code>()</code>，只给出存储过程。</p>
<p><strong>仅当存在时删除</strong> 如果指定的过程不存在，则DROP PROCEDURE将产生一个错误。当过程存在想删除它时(如果过程不存在也不产生错误)可使用<code>DROP PROCEDURE IF EXISTS</code>。</p>
<h3 id="2334-使用参数"><a class="header" href="#2334-使用参数">23.3.4 使用参数</a></h3>
<p>productpricing只是一个简单的存储过程，它简单地显示SELECT语句的结果。一般，存储过程并不显示结果，而是把结果返回给你指定的变量。</p>
<p><strong>变量(variable)</strong> 内存中一个特定的位置，用来临时存储数据。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; DELIMITER //
MariaDB [testdatabase]&gt;
MariaDB [testdatabase]&gt; CREATE PROCEDURE productpricing(
    -&gt;     OUT pl DECIMAL(8, 2),
    -&gt;     OUT ph DECIMAL(8, 2),
    -&gt;     OUT pa DECIMAL(8, 2)
    -&gt; )
    -&gt; BEGIN
    -&gt;     SELECT Min(prod_price)
    -&gt;     INTO pl
    -&gt;     FROM products;
    -&gt;     SELECT Max(prod_price)
    -&gt;     INTO ph
    -&gt;     FROM products;
    -&gt;     SELECT Avg(prod_price)
    -&gt;     INTO pa
    -&gt;     FROM products;
    -&gt; END //
Query OK, 0 rows affected (0.001 sec)

MariaDB [testdatabase]&gt; 
MariaDB [testdatabase]&gt; DELIMITER ;
</code></pre>
<p>此存储过程接受3个参数：pl存储产品最低价格，ph存储产品最高价格，pa存储产品平均价格。</p>
<p>关键字OUT指出相应的参数用来<code>从存储过程传出一个值（返回给调用者）</code>。</p>
<p>MySQL支持IN（传递给存储过程）、OUT（从存储过程传出，如这里所用）和INOUT（对存储过程传入和传出）类型的参数。</p>
<p>存储过程的代码位于BEGIN和END语句内，如前所见，它们是一系列SELECT语句，用来检索值，然后保存到相应的变量（通过指定INTO关键字）。 </p>
<p><strong>参数的数据类型</strong> 存储过程的参数允许的数据类型与表中使用的数据类型相同。注意，记录集不是允许的类型，因此，不能通过一个参数返回多个行和列。</p>
<p>为调用此修改的存储过程，必须指定3个变量名，如</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; CALL productpricing(@pricelow, @pricehigh, @priceaverage);
Query OK, 3 rows affected, 1 warning (0.001 sec)
</code></pre>
<p>由于此存储过程要求3个参数，因此必须正好传递3个参数。</p>
<p><strong>变量名</strong> 所有MySQl变量都必须以@开始。</p>
<p>在调用时，这条语句并不显示任何数据。他返回以后可以显示的变量，为了显示检索出的产品平均价格，可如下进行：</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; SELECT @priceaverage;
+---------------+
| @priceaverage |
+---------------+
|         16.13 |
+---------------+
1 row in set (0.000 sec)

MariaDB [testdatabase]&gt; SELECT @priceaverage, @pricelow, @priceaverage;
+---------------+-----------+---------------+
| @priceaverage | @pricelow | @priceaverage |
+---------------+-----------+---------------+
|         16.13 |      2.50 |         16.13 |
+---------------+-----------+---------------+
1 row in set (0.000 sec)
</code></pre>
<p>下面是另外一个例子，使用IN和OUT参数。ordertotal接受订单号并返回该订单的合计：</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; DELIMITER //
MariaDB [testdatabase]&gt; 
MariaDB [testdatabase]&gt; CREATE PROCEDURE ordertotal(
    -&gt;     IN onumber INT,
    -&gt;     OUT ototal DECIMAL(8, 2)
    -&gt; )
    -&gt; BEGIN
    -&gt; SELECT Sum(item_price*quantity) FROM orderitems WHERE order_num=onumber INTO ototal;
    -&gt; END //
Query OK, 0 rows affected (0.006 sec)

MariaDB [testdatabase]&gt; 
MariaDB [testdatabase]&gt; DELIMITER ;
</code></pre>
<p>onumber定义为IN，因此订单号被传入存储过程。ototal定义为OUT，因为要从存储过程返回合计。使用方法如下：</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; CALL ordertotal(20005, @total);
Query OK, 1 row affected (0.001 sec)

MariaDB [testdatabase]&gt; SELECT @total;
+--------+
| @total |
+--------+
| 149.87 |
+--------+
1 row in set (0.000 sec)
</code></pre>
<h3 id="2335-建立智能存储过程"><a class="header" href="#2335-建立智能存储过程">23.3.5 建立智能存储过程</a></h3>
<p>在存储过程内包含业务规则和智能处理</p>
<pre><code class="language-SQL">-- Name: ordertotal
-- Parameters:  onumber = order number
--              taxable = 0 if not taxable, 1 if taxable
--              ototal  = order totoal variable

CREATE PROCEDURE ordertotal(
    IN onumber INT,
    IN taxable BOOLEAN,
    OUT ototal DECIMAL(8,2)
) COMMENT 'Obtain order total, optinally adding tax'
BEGIN
    -- Declare variable for total
    DECLARE total DECIMAL(8,2);
    -- Declare tax percentage
    DECLARE taxrate INT DEFAULT 6;

    -- Get the order total
    SELECT Sum(item_price*quantity) FROM orderitems WHERE order_num=onumber INTO total;

    -- Is this taxable?
    IF taxable THEN
        -- Yes, so add taxable to the total
        SELECT total+(total/100*taxrate) INTO total;
    END IF;

    -- And finally, save to out variable
    SELECT total INTO ototal;
END;
</code></pre>
<p>此存储过程增加了注释(前面放置<code>--</code>)。</p>
<p>DECLARE语句定义局部变量，DECLARE要求指定变量名和数据类型，也支持可选的默认值</p>
<p>IF语句检查taxable是否为真，如果为真，则用另一SELECT语句增加营业税到局部变量total。</p>
<p><strong>COMMENT关键字</strong> 本例子中的存储过程在CREATE PROCEDURE语句中包含了一个COMMENT值。它不是必需的，但如果给出，将在<code>SHOW PROCEDURE STATUS</code>的结果中显示。</p>
<p><strong>IF语句</strong> 这个例子给出了MySQL的IF语句的基本用法。IF语句还支持ELSEIF和ELSE子句（前者还使用THEN子句，后者不使用）。</p>
<h3 id="2336-检查存储过程"><a class="header" href="#2336-检查存储过程">23.3.6 检查存储过程</a></h3>
<p>为显示用来创建一个存储过程的CREATE语句，使用<code>SHOW CREATE PROCEDURE &lt;procedure名称&gt;;</code>语句。</p>
<p>使用<code>SHOW PROCEDURE STATUS</code>获得包括何时、由谁创建等详细信息的存储过程列表。</p>
<p><strong>限制过程状态结果</strong> <code>SHOW PROCEDURE STATUS</code>列出所有存储过程。为限制其输出，可使用LIKE指定一个过滤模式，例如：<code>SHOW PROCEDURE STATUS LIKE 'ordertotal';</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="24-使用游标"><a class="header" href="#24-使用游标">24 使用游标</a></h1>
<h2 id="241-游标"><a class="header" href="#241-游标">24.1 游标</a></h2>
<p>有时，需要在检索出来的行中前进或后退一行或多行。这就是游标的用处。</p>
<p><strong>游标（cursor）</strong> 是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。</p>
<p>游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。</p>
<p><strong>只能用于存储过程</strong> 不像多数DBMS，MySQL游标只能用于存储过程（和函数）。</p>
<h2 id="242-使用游标"><a class="header" href="#242-使用游标">24.2 使用游标</a></h2>
<p>使用游标的几个明确的步骤：</p>
<ul>
<li>先声明(定义)它。这个过程实际上没有检索数据，它只是定义要使用的SELECT语句。</li>
<li>声明后，必须打开游标以供使用。这个过程用前面定义的SELECT语句吧数据实际检索出来。</li>
<li>对于填有数据的游标，根据需要取出(检索各行)。</li>
<li>在结束游标使用时，必须关闭游标。</li>
</ul>
<p>在游标声明后，可以根据需要频繁打开和关闭。在游标打开后，可以根据需要频繁地执行取操作。</p>
<h3 id="2421-创建游标"><a class="header" href="#2421-创建游标">24.2.1 创建游标</a></h3>
<p>DELCLARE命名游标并定义相应的SELECT语句，根据需要带WHERE和其他子句。</p>
<pre><code class="language-SQL">MariaDB [testdatabase]&gt; DELIMITER //
MariaDB [testdatabase]&gt; CREATE PROCEDURE processorders()
    -&gt; BEGIN
    -&gt; DECLARE ordernumbers CURSOR FOR SELECT order_num FROM orders;
    -&gt; END //
Query OK, 0 rows affected (0.007 sec)

MariaDB [testdatabase]&gt; DELIMITER ;
</code></pre>
<p>DECLARE语句定义和命名游标为ordernumbers。存储过程处理完成后，游标就消失（因为它局限于存储过程）。</p>
<h3 id="2422-打开和关闭游标"><a class="header" href="#2422-打开和关闭游标">24.2.2 打开和关闭游标</a></h3>
<p>用<code>OPEN &lt;游标名&gt;;</code>语句打开游标。用<code>CLOSE &lt;游标名&gt;;</code>语句关闭游标。</p>
<p><em>在处理OPEN语句时执行查询</em>，存储检索出的数据以供浏览和滚动。 </p>
<p><em>CLOSE释放游标使用的所有内部内存和资源</em>，因此在每个游标不再需要时都应该关闭。在一个游标关闭后，如果没有重新打开，则不能使用它。但是，使用声明过的游标不需要再次声明，用OPEN语句打开它就可以了。</p>
<p><strong>隐含关闭</strong> 如果你不明确关闭游标，MySQL将会在到达END语句时自动关闭它。</p>
<h3 id="2423-使用游标数据"><a class="header" href="#2423-使用游标数据">24.2.3 使用游标数据</a></h3>
<p>在一个游标被打开后，可以使用FETCH语句分别访问它的每一行。FETCH指定检索什么数据（所需的列），检索出来的数据存储在什么地方。它还向前移动游标中的内部行指针，使下一条FETCH语句检索下一行（不重复读取同一行）。</p>
<pre><code class="language-SQL">CREATE PROCEDURE proicessorders()
BEGIN
    -- Declare local variables
    DECLARE done BOOLEAN DEFAULT 0;
    DECLARE o INT;

    -- Declare the cuesor
    DECLARE ordernumbers CURSOR FOR SELECT order_num FROM orders;

    -- Declare continue handler
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done=1;

    -- Open the cursor
    OPEN ordernumbers;

    -- Loop through all rows
    REPEAT

        -- Get order number
        FETCH ordernumbers INTO o;

    -- End of loop
    UNTIL done END REPEAT;

    -- Close the cursor
    CLOSE ordernumbers;
END;
</code></pre>
<p>FETCH检索当前order_num到声明的名为o的变量中。</p>
<p>FETCH在REPEAT内，因此它反复执行知道done为真(由<code>UNTIL done END REPEAT;</code>规定)。为了使它起作用，用一个DEFAULT 0定义变量done。</p>
<p><code>DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done=1;</code>这条语句定义了一个<code>CONTINUE HANDLER</code>，它是在条件出现时被执行的代码。这里表示当<code>SQLSTATE '02000'</code>出现时，SET done=1。</p>
<p><code>SQLSTATE '02000'</code>是一个未找到条件，当REPEAT由于没有更多行供循环而不能继续时出现这个条件。</p>
<p><strong>MySQL的错误代码</strong> 关于MySQL 5使用的MySQL错误代码列表，请参阅<a href="http://dev.mysql.com/doc/mysql/en/error-handling.html">http://dev.mysql.com/doc/mysql/en/error-handling.html</a>。</p>
<p><strong>DECLARE语句的次序</strong> DECLARE语句的发布存在特定的次序。用DECLARE语句定义的局部变量必须在定义任意游标或句柄(HANDLER)之前定义，而句柄必须在游标之后定义。不遵守此顺序将产生错误消息。即<code>变量-&gt;游标-&gt;句柄</code>。</p>
<p>如果一切正常，你可以在循环内放入任意需要的处理（在FETCH语句之后，循环结束之前）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="25-使用触发器"><a class="header" href="#25-使用触发器">25 使用触发器</a></h1>
<h2 id="251-触发器"><a class="header" href="#251-触发器">25.1 触发器</a></h2>
<p>触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语句）：</p>
<ul>
<li>DELETE；</li>
<li>INSERT；</li>
<li>UPDATE。</li>
</ul>
<p>其他的MySQL语句不支持触发器。</p>
<h1 id="252-创建触发器"><a class="header" href="#252-创建触发器">25.2 创建触发器</a></h1>
<p>创建触发器时，需要给出4条信息：</p>
<ul>
<li>唯一的触发器名；</li>
<li>触发器关联的表；</li>
<li>触发器应该响应的活动(DELETE、INSERT或UPDATE)；</li>
<li>触发器何时执行(处理之前或之后)。</li>
</ul>
<p><strong>保持每个数据库的触发器名唯一</strong> 截至这本书发行的时候，MySQL触发器名必须在每个表中唯一，但不是在每个数据库中唯一。这表示同一数据库中的两个表可具有相同名字的触发器。这在其他<em>每个数据库触发器名必须唯一</em>的DBMS中是不允许的，而且以后的MySQL版本很可能会使命名规则更为严格。因此，现在最好是在数据库范围内使用唯一的触发器名。</p>
<p>使用<code>CREATE TRIGGER</code>语句创建触发器。</p>
<pre><code class="language-SQL">-- 该语句在8.0版本的MySQL中执行不了。待修改
MariaDB [testdatabase]&gt; CREATE TRIGGER newproduct AFTER INSERT ON products FOR EACH ROW SELECT 'Product added';
ERROR 1415 (0A000): Not allowed to return a result set from a trigger
</code></pre>
<p>该语句在products表创建一个名为newproduct的在INSERT完成后触发的触发器，针对成功插入的每一行都会显示“Product added”。</p>
<p><strong>仅支持表</strong> 只有表支持触发器，视图不支持(临时表也不支持)。</p>
<p><strong>触发器失败</strong> 如果BEFORE触发器失败，则MySQL将不执行请求的操作。此外，如果BEFORE触发器或语句本身失败，MySQL 将不执行AFTER触发器(如果有的话)。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="26-管理事务处理"><a class="header" href="#26-管理事务处理">26 管理事务处理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mysql数据类型"><a class="header" href="#mysql数据类型">MySQL数据类型</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="创建示例数据库结构"><a class="header" href="#创建示例数据库结构">创建示例数据库结构</a></h1>
<pre><code class="language-SQL">########################################
# MySQL Crash Course
# http://www.forta.com/books/0672327120/
# Example table creation scripts
########################################


########################
# Create customers table
########################
CREATE TABLE customers
(
  cust_id      int       NOT NULL AUTO_INCREMENT,
  cust_name    char(50)  NOT NULL ,
  cust_address char(50)  NULL ,
  cust_city    char(50)  NULL ,
  cust_state   char(5)   NULL ,
  cust_zip     char(10)  NULL ,
  cust_country char(50)  NULL ,
  cust_contact char(50)  NULL ,
  cust_email   char(255) NULL ,
  PRIMARY KEY (cust_id)
) ENGINE=InnoDB;

#########################
# Create orderitems table
#########################
CREATE TABLE orderitems
(
  order_num  int          NOT NULL ,
  order_item int          NOT NULL ,
  prod_id    char(10)     NOT NULL ,
  quantity   int          NOT NULL ,
  item_price decimal(8,2) NOT NULL ,
  PRIMARY KEY (order_num, order_item)
) ENGINE=InnoDB;


#####################
# Create orders table
#####################
CREATE TABLE orders
(
  order_num  int      NOT NULL AUTO_INCREMENT,
  order_date datetime NOT NULL ,
  cust_id    int      NOT NULL ,
  PRIMARY KEY (order_num)
) ENGINE=InnoDB;

#######################
# Create products table
#######################
CREATE TABLE products
(
  prod_id    char(10)      NOT NULL,
  vend_id    int           NOT NULL ,
  prod_name  char(255)     NOT NULL ,
  prod_price decimal(8,2)  NOT NULL ,
  prod_desc  text          NULL ,
  PRIMARY KEY(prod_id)
) ENGINE=InnoDB;

######################
# Create vendors table
######################
CREATE TABLE vendors
(
  vend_id      int      NOT NULL AUTO_INCREMENT,
  vend_name    char(50) NOT NULL ,
  vend_address char(50) NULL ,
  vend_city    char(50) NULL ,
  vend_state   char(5)  NULL ,
  vend_zip     char(10) NULL ,
  vend_country char(50) NULL ,
  PRIMARY KEY (vend_id)
) ENGINE=InnoDB;

###########################
# Create productnotes table
###########################
CREATE TABLE productnotes
(
  note_id    int           NOT NULL AUTO_INCREMENT,
  prod_id    char(10)      NOT NULL,
  note_date datetime       NOT NULL,
  note_text  text          NULL ,
  PRIMARY KEY(note_id),
  FULLTEXT(note_text)
) ENGINE=MyISAM;


#####################
# Define foreign keys
#####################
ALTER TABLE orderitems ADD CONSTRAINT fk_orderitems_orders FOREIGN KEY (order_num) REFERENCES orders (order_num);
ALTER TABLE orderitems ADD CONSTRAINT fk_orderitems_products FOREIGN KEY (prod_id) REFERENCES products (prod_id);
ALTER TABLE orders ADD CONSTRAINT fk_orders_customers FOREIGN KEY (cust_id) REFERENCES customers (cust_id);
ALTER TABLE products ADD CONSTRAINT fk_products_vendors FOREIGN KEY (vend_id) REFERENCES vendors (vend_id);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="添加示例数据"><a class="header" href="#添加示例数据">添加示例数据</a></h1>
<pre><code class="language-SQL">########################################
# MySQL Crash Course
# http://www.forta.com/books/0672327120/
# Example table population scripts
########################################


##########################
# Populate customers table
##########################
INSERT INTO customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)
VALUES(10001, 'Coyote Inc.', '200 Maple Lane', 'Detroit', 'MI', '44444', 'USA', 'Y Lee', 'ylee@coyote.com');
INSERT INTO customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact)
VALUES(10002, 'Mouse House', '333 Fromage Lane', 'Columbus', 'OH', '43333', 'USA', 'Jerry Mouse');
INSERT INTO customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)
VALUES(10003, 'Wascals', '1 Sunny Place', 'Muncie', 'IN', '42222', 'USA', 'Jim Jones', 'rabbit@wascally.com');
INSERT INTO customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)
VALUES(10004, 'Yosemite Place', '829 Riverside Drive', 'Phoenix', 'AZ', '88888', 'USA', 'Y Sam', 'sam@yosemite.com');
INSERT INTO customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact)
VALUES(10005, 'E Fudd', '4545 53rd Street', 'Chicago', 'IL', '54545', 'USA', 'E Fudd');


########################
# Populate vendors table
########################
INSERT INTO vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)
VALUES(1001,'Anvils R Us','123 Main Street','Southfield','MI','48075', 'USA');
INSERT INTO vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)
VALUES(1002,'LT Supplies','500 Park Street','Anytown','OH','44333', 'USA');
INSERT INTO vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)
VALUES(1003,'ACME','555 High Street','Los Angeles','CA','90046', 'USA');
INSERT INTO vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)
VALUES(1004,'Furball Inc.','1000 5th Avenue','New York','NY','11111', 'USA');
INSERT INTO vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)
VALUES(1005,'Jet Set','42 Galaxy Road','London', NULL,'N16 6PS', 'England');
INSERT INTO vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)
VALUES(1006,'Jouets Et Ours','1 Rue Amusement','Paris', NULL,'45678', 'France');


#########################
# Populate products table
#########################
INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)
VALUES('ANV01', 1001, '.5 ton anvil', 5.99, '.5 ton anvil, black, complete with handy hook');
INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)
VALUES('ANV02', 1001, '1 ton anvil', 9.99, '1 ton anvil, black, complete with handy hook and carrying case');
INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)
VALUES('ANV03', 1001, '2 ton anvil', 14.99, '2 ton anvil, black, complete with handy hook and carrying case');
INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)
VALUES('OL1', 1002, 'Oil can', 8.99, 'Oil can, red');
INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)
VALUES('FU1', 1002, 'Fuses', 3.42, '1 dozen, extra long');
INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)
VALUES('SLING', 1003, 'Sling', 4.49, 'Sling, one size fits all');
INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)
VALUES('TNT1', 1003, 'TNT (1 stick)', 2.50, 'TNT, red, single stick');
INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)
VALUES('TNT2', 1003, 'TNT (5 sticks)', 10, 'TNT, red, pack of 10 sticks');
INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)
VALUES('FB', 1003, 'Bird seed', 10, 'Large bag (suitable for road runners)');
INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)
VALUES('FC', 1003, 'Carrots', 2.50, 'Carrots (rabbit hunting season only)');
INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)
VALUES('SAFE', 1003, 'Safe', 50, 'Safe with combination lock');
INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)
VALUES('DTNTR', 1003, 'Detonator', 13, 'Detonator (plunger powered), fuses not included');
INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)
VALUES('JP1000', 1005, 'JetPack 1000', 35, 'JetPack 1000, intended for single use');
INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)
VALUES('JP2000', 1005, 'JetPack 2000', 55, 'JetPack 2000, multi-use');



#######################
# Populate orders table
#######################
INSERT INTO orders(order_num, order_date, cust_id)
VALUES(20005, '2005-09-01', 10001);
INSERT INTO orders(order_num, order_date, cust_id)
VALUES(20006, '2005-09-12', 10003);
INSERT INTO orders(order_num, order_date, cust_id)
VALUES(20007, '2005-09-30', 10004);
INSERT INTO orders(order_num, order_date, cust_id)
VALUES(20008, '2005-10-03', 10005);
INSERT INTO orders(order_num, order_date, cust_id)
VALUES(20009, '2005-10-08', 10001);


###########################
# Populate orderitems table
###########################
INSERT INTO orderitems(order_num, order_item, prod_id, quantity, item_price)
VALUES(20005, 1, 'ANV01', 10, 5.99);
INSERT INTO orderitems(order_num, order_item, prod_id, quantity, item_price)
VALUES(20005, 2, 'ANV02', 3, 9.99);
INSERT INTO orderitems(order_num, order_item, prod_id, quantity, item_price)
VALUES(20005, 3, 'TNT2', 5, 10);
INSERT INTO orderitems(order_num, order_item, prod_id, quantity, item_price)
VALUES(20005, 4, 'FB', 1, 10);
INSERT INTO orderitems(order_num, order_item, prod_id, quantity, item_price)
VALUES(20006, 1, 'JP2000', 1, 55);
INSERT INTO orderitems(order_num, order_item, prod_id, quantity, item_price)
VALUES(20007, 1, 'TNT2', 100, 10);
INSERT INTO orderitems(order_num, order_item, prod_id, quantity, item_price)
VALUES(20008, 1, 'FC', 50, 2.50);
INSERT INTO orderitems(order_num, order_item, prod_id, quantity, item_price)
VALUES(20009, 1, 'FB', 1, 10);
INSERT INTO orderitems(order_num, order_item, prod_id, quantity, item_price)
VALUES(20009, 2, 'OL1', 1, 8.99);
INSERT INTO orderitems(order_num, order_item, prod_id, quantity, item_price)
VALUES(20009, 3, 'SLING', 1, 4.49);
INSERT INTO orderitems(order_num, order_item, prod_id, quantity, item_price)
VALUES(20009, 4, 'ANV03', 1, 14.99);

#############################
# Populate productnotes table
#############################
INSERT INTO productnotes(note_id, prod_id, note_date, note_text)
VALUES(101, 'TNT2', '2005-08-17',
'Customer complaint:
Sticks not individually wrapped, too easy to mistakenly detonate all at once.
Recommend individual wrapping.'
);
INSERT INTO productnotes(note_id, prod_id, note_date, note_text)
VALUES(102, 'OL1', '2005-08-18',
'Can shipped full, refills not available.
Need to order new can if refill needed.'
);
INSERT INTO productnotes(note_id, prod_id, note_date, note_text)
VALUES(103, 'SAFE', '2005-08-18',
'Safe is combination locked, combination not provided with safe.
This is rarely a problem as safes are typically blown up or dropped by customers.'
);
INSERT INTO productnotes(note_id, prod_id, note_date, note_text)
VALUES(104, 'FC', '2005-08-19',
'Quantity varies, sold by the sack load.
All guaranteed to be bright and orange, and suitable for use as rabbit bait.'
);
INSERT INTO productnotes(note_id, prod_id, note_date, note_text)
VALUES(105, 'TNT2', '2005-08-20',
'Included fuses are short and have been known to detonate too quickly for some customers.
Longer fuses are available (item FU1) and should be recommended.'
);
INSERT INTO productnotes(note_id, prod_id, note_date, note_text)
VALUES(106, 'TNT2', '2005-08-22',
'Matches not included, recommend purchase of matches or detonator (item DTNTR).'
);
INSERT INTO productnotes(note_id, prod_id, note_date, note_text)
VALUES(107, 'SAFE', '2005-08-23',
'Please note that no returns will be accepted if safe opened using explosives.'
);
INSERT INTO productnotes(note_id, prod_id, note_date, note_text)
VALUES(108, 'ANV01', '2005-08-25',
'Multiple customer returns, anvils failing to drop fast enough or falling backwards on purchaser. Recommend that customer considers using heavier anvils.'
);
INSERT INTO productnotes(note_id, prod_id, note_date, note_text)
VALUES(109, 'ANV03', '2005-09-01',
'Item is extremely heavy. Designed for dropping, not recommended for use with slings, ropes, pulleys, or tightropes.'
);
INSERT INTO productnotes(note_id, prod_id, note_date, note_text)
VALUES(110, 'FC', '2005-09-01',
'Customer complaint: rabbit has been able to detect trap, food apparently less effective now.'
);
INSERT INTO productnotes(note_id, prod_id, note_date, note_text)
VALUES(111, 'SLING', '2005-09-02',
'Shipped unassembled, requires common tools (including oversized hammer).'
);
INSERT INTO productnotes(note_id, prod_id, note_date, note_text)
VALUES(112, 'SAFE', '2005-09-02',
'Customer complaint:
Circular hole in safe floor can apparently be easily cut with handsaw.'
);
INSERT INTO productnotes(note_id, prod_id, note_date, note_text)
VALUES(113, 'ANV01', '2005-09-05',
'Customer complaint:
Not heavy enough to generate flying stars around head of victim. If being purchased for dropping, recommend ANV02 or ANV03 instead.'
);
INSERT INTO productnotes(note_id, prod_id, note_date, note_text)
VALUES(114, 'SAFE', '2005-09-07',
'Call from individual trapped in safe plummeting to the ground, suggests an escape hatch be added.
Comment forwarded to vendor.'
);
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
