# 5 排序检索数据

检索出的数据并不是以纯粹的随机顺序显示的。如果不排序，数据一般将以它在底层表中出现的顺序显示。这可以是数据最初添加到表中的顺序。但是，如果数据后来进行过更新或删除，则此顺序将会受到MySQL重用回收存储空间的影响。因此，如果不明确控制的话，不能（也不应该）依赖该排序顺序。关系数据库设计理论认为，如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有意义。  

## 5.1 排序数据

**子句（clause）** SQL语句由子句构成，有些子句是必需的，而有的是可选的。一个子句通常由一个关键字和所提供的数据组成。

```SQL
MariaDB [testdatabase]> SELECT Name FROM tasks ORDER BY Id;
+-----------------+
| Name            |
+-----------------+
| db_create_test  |
| db_create_test1 |
+-----------------+
2 rows in set (0.000 sec)

MariaDB [testdatabase]> SELECT Name FROM tasks ORDER BY Id DESC;
+-----------------+
| Name            |
+-----------------+
| db_create_test1 |
| db_create_test  |
+-----------------+
2 rows in set (0.000 sec)
```

ORDER BY子句取一个或多个列的名字，据此对输出进行排序。

**通过非选择列进行排序** 通常，ORDER BY子句中使用的列将是为显示所选择的列。但是，实际上并不一定要这样，用非检索的列排序数据是完全合法的。

## 5.2 按多个列排序

为了按多个列排序，只要指定列名，列名之间用逗号分开即可（就像选择多个列时所做的那样）。

```SQL
MariaDB [testdatabase]> SELECT id,fault,correct FROM tasks ORDER BY fault, id;
+----+-------+---------+
| id | fault | correct |
+----+-------+---------+
|  2 |     0 |       1 |
|  1 |     1 |       0 |
|  3 |     1 |       0 |
+----+-------+---------+
3 rows in set (0.010 sec)
```

重要的是理解在按多个列排序时，排序完全按所规定的顺序进行。换句话说，对于上述例子中的输出，仅在多个行具有相同的fault值时才对产品按id进行排序。如果fault列中所有的值都是唯一的，则不会按id排序。

## 5.3 指定排序方向

```SQL
MariaDB [testdatabase]> SELECT id,fault,correct FROM tasks ORDER BY fault, id;
+----+-------+---------+
| id | fault | correct |
+----+-------+---------+
|  2 |     0 |       1 |
|  1 |     1 |       0 |
|  3 |     1 |       0 |
+----+-------+---------+
3 rows in set (0.000 sec)

MariaDB [testdatabase]> SELECT id,fault,correct FROM tasks ORDER BY fault, id DESC;
+----+-------+---------+
| id | fault | correct |
+----+-------+---------+
|  2 |     0 |       1 |
|  3 |     1 |       0 |
|  1 |     1 |       0 |
+----+-------+---------+
3 rows in set (0.000 sec)
```

DESC关键字只应用到直接位于其前面的列名。在上例中，只对id列指定DESC，对fault列不指定。因此，id列以降序排序，而fault列仍然按标准的升序排序。

**在多个列上降序排序** 如果想在多个列上进行降序排序，必须对每个列指定DESC关键字。

**区分大小写和排序顺序** 在对文本性的数据进行排序时，A与a相同吗？a位于B之前还是位于Z之后？这些问题不是理论问题，其答案取决于数据库如何设置。
  * 在字典（dictionary）排序顺序中，A被视为与a相同，这是MySQL（和大多数数据库管理系统）的默认行为。但是，许多数据库管理员能够在需要时改变这种行为（如果你的数据库包含大量外语字符，可能必须这样做）。
  * 这里，关键的问题是，如果确实需要改变这种排序顺序，用简单的ORDER BY子句做不到。你必须请求数据库管理员的帮助。

**ORDER BY子句的位置** 在给出ORDER BY子句时，应该保证它位于FROM子句之后。如果使用LIMIT，它必须位于ORDER BY之后。使用子句的次序不对将产生错误消息。